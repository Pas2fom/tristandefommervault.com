import * as yup from "yup";
import UrlPattern from "url-pattern";
import z$1, { z, ZodError } from "zod";
function addNamespaceToSchema(maybeNode, namespace = []) {
  if (typeof maybeNode === "string") {
    return maybeNode;
  }
  if (typeof maybeNode === "boolean") {
    return maybeNode;
  }
  if (typeof maybeNode === "function") {
    return maybeNode;
  }
  const newNode = { ...maybeNode };
  const keys = Object.keys(maybeNode);
  Object.values(maybeNode).map((m, index) => {
    const key = keys[index];
    if (Array.isArray(m)) {
      newNode[key] = m.map((element) => {
        if (!element) {
          return;
        }
        if (!element.hasOwnProperty("name")) {
          return element;
        }
        const value = element.name || element.value;
        return addNamespaceToSchema(element, [...namespace, value]);
      });
    } else {
      if (!m) {
        return;
      }
      if (!m.hasOwnProperty("name")) {
        newNode[key] = m;
      } else {
        newNode[key] = addNamespaceToSchema(m, [...namespace, m.name]);
      }
    }
  });
  return { ...newNode, namespace };
}
function assertShape(value, yupSchema, errorMessage) {
  const shape = yupSchema(yup);
  try {
    shape.validateSync(value);
  } catch (e) {
    const message = errorMessage || `Failed to assertShape - ${e.message}`;
    throw new Error(message);
  }
}
const lastItem = (arr) => {
  if (typeof arr === "undefined") {
    throw new Error("Can not call lastItem when arr is undefined");
  }
  return arr[arr.length - 1];
};
const capitalize = (s) => {
  if (typeof s !== "string")
    return "";
  return s.charAt(0).toUpperCase() + s.slice(1);
};
const generateNamespacedFieldName = (names, suffix = "") => {
  return (suffix ? [...names, suffix] : names).map(capitalize).join("");
};
const NAMER = {
  dataFilterTypeNameOn: (namespace) => {
    return generateNamespacedFieldName(namespace, "_FilterOn");
  },
  dataFilterTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Filter");
  },
  dataMutationTypeNameOn: (namespace) => {
    return generateNamespacedFieldName(namespace, "_MutationOn");
  },
  dataMutationTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Mutation");
  },
  updateName: (namespace) => {
    return "update" + generateNamespacedFieldName(namespace, "Document");
  },
  createName: (namespace) => {
    return "create" + generateNamespacedFieldName(namespace, "Document");
  },
  queryName: (namespace) => {
    return "get" + generateNamespacedFieldName(namespace, "Document");
  },
  generateQueryListName: (namespace) => {
    return "get" + generateNamespacedFieldName(namespace, "List");
  },
  fragmentName: (namespace) => {
    return generateNamespacedFieldName(namespace, "") + "Parts";
  },
  collectionTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Collection");
  },
  documentTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Document");
  },
  dataTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "");
  },
  referenceConnectionType: (namespace) => {
    return generateNamespacedFieldName(namespace, "Connection");
  },
  referenceConnectionEdgesTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "ConnectionEdges");
  }
};
function findDuplicates(array = []) {
  const duplicates = [
    ...new Set(array.filter((item, index) => array.indexOf(item) !== index))
  ].map((x) => `"${x}"`);
  if (duplicates.length) {
    return duplicates.join(", ");
  } else
    return void 0;
}
const TINA_HOST = "content.tinajs.io";
const parseURL = (url) => {
  if (url.startsWith("/")) {
    return {
      branch: null,
      isLocalClient: false,
      clientId: null,
      host: null
    };
  }
  if (url.includes("localhost")) {
    return {
      branch: null,
      isLocalClient: true,
      clientId: null,
      host: "localhost"
    };
  }
  const params = new URL(url);
  const isTinaCloud = params.host.includes("tinajs.dev") || params.host.includes("tina.io") || params.host.includes("tinajs.io");
  if (!isTinaCloud) {
    return {
      branch: null,
      isLocalClient: true,
      clientId: null,
      host: params.host
    };
  }
  const pattern = new UrlPattern("/content/:clientId/github/*", {
    escapeChar: " "
  });
  const result = pattern.match(params.pathname);
  const branch = result == null ? void 0 : result._;
  const clientId = result == null ? void 0 : result.clientId;
  if (!branch || !clientId) {
    throw new Error(`Invalid URL format provided. Expected: https://content.tinajs.io/content/<ClientID>/github/<Branch> but but received ${url}`);
  }
  return {
    host: params.host,
    branch,
    clientId,
    isLocalClient: false
  };
};
class TinaSchema {
  constructor(config) {
    this.config = config;
    this.getIsTitleFieldName = (collection) => {
      var _a;
      const col = this.getCollection(collection);
      const field = (_a = col == null ? void 0 : col.fields) == null ? void 0 : _a.find((x) => x.type === "string" && x.isTitle);
      return field == null ? void 0 : field.name;
    };
    this.getCollectionsByName = (collectionNames) => {
      return this.schema.collections.filter((collection) => collectionNames.includes(collection.name));
    };
    this.getAllCollectionPaths = () => {
      const paths = this.getCollections().map((collection) => `${collection.path}${collection.match || ""}`);
      return paths;
    };
    this.getCollection = (collectionName) => {
      const collection = this.schema.collections.find((collection2) => collection2.name === collectionName);
      if (!collection) {
        throw new Error(`Expected to find collection named ${collectionName}`);
      }
      const extraFields = {};
      const templateInfo = this.getTemplatesForCollectable(collection);
      switch (templateInfo.type) {
        case "object":
          extraFields["fields"] = templateInfo.template.fields;
          break;
        case "union":
          extraFields["templates"] = templateInfo.templates;
          break;
      }
      return {
        slug: collection.name,
        ...extraFields,
        ...collection,
        format: collection.format || "md"
      };
    };
    this.getCollections = () => {
      return this.schema.collections.map((collection) => this.getCollection(collection.name)) || [];
    };
    this.getGlobalTemplate = (templateName) => {
      var _a;
      const globalTemplate = (_a = this.schema.templates) == null ? void 0 : _a.find((template) => template.name === templateName);
      if (!globalTemplate) {
        throw new Error(`Expected to find global template of name ${templateName}`);
      }
      return globalTemplate;
    };
    this.getCollectionByFullPath = (filepath) => {
      const possibleCollections = this.getCollections().filter((collection) => {
        return filepath.replace(/\\/g, "/").startsWith(collection.path.replace(/\/?$/, "/"));
      });
      if (possibleCollections.length === 0) {
        throw new Error(`Unable to find collection for file at ${filepath}`);
      }
      if (possibleCollections.length === 1) {
        return possibleCollections[0];
      }
      if (possibleCollections.length > 1) {
        const longestMatch = possibleCollections.reduce((acc, collection) => {
          if (collection.path.length > acc.path.length) {
            return collection;
          }
          return acc;
        });
        return longestMatch;
      }
    };
    this.getCollectionAndTemplateByFullPath = (filepath, templateName) => {
      let template;
      const collection = this.getCollectionByFullPath(filepath);
      const templates = this.getTemplatesForCollectable(collection);
      if (templates.type === "union") {
        if (templateName) {
          template = templates.templates.find((template2) => lastItem(template2.namespace) === templateName);
          if (!template) {
            throw new Error(`Unable to determine template for item at ${filepath}`);
          }
        } else {
          throw new Error(`Unable to determine template for item at ${filepath}, no template name provided for collection with multiple templates`);
        }
      }
      if (templates.type === "object") {
        template = templates.template;
      }
      if (!template) {
        throw new Error(`Something went wrong while trying to determine template for ${filepath}`);
      }
      return { collection, template };
    };
    this.getTemplateForData = ({
      data,
      collection
    }) => {
      const templateInfo = this.getTemplatesForCollectable(collection);
      switch (templateInfo.type) {
        case "object":
          return templateInfo.template;
        case "union":
          assertShape(data, (yup2) => yup2.object({ _template: yup2.string().required() }));
          const template = templateInfo.templates.find((template2) => template2.namespace[template2.namespace.length - 1] === data._template);
          if (!template) {
            throw new Error(`Expected to find template named '${data._template}' for collection '${lastItem(collection.namespace)}'`);
          }
          return template;
      }
    };
    this.transformPayload = (collectionName, payload) => {
      const collection = this.getCollection(collectionName);
      if (collection.templates) {
        const template = collection.templates.find((template2) => {
          if (typeof template2 === "string") {
            throw new Error("Global templates not supported");
          }
          return payload["_template"] === template2.name;
        });
        if (!template) {
          console.error(payload);
          throw new Error(`Unable to find template for payload`);
        }
        if (typeof template === "string") {
          throw new Error("Global templates not supported");
        }
        return {
          [collectionName]: {
            [template.name]: this.transformCollectablePayload(payload, template)
          }
        };
      } else {
        return {
          [collectionName]: this.transformCollectablePayload(payload, collection)
        };
      }
    };
    this.transformCollectablePayload = (payload, collection) => {
      const accumulator = {};
      Object.entries(payload).forEach(([key, value]) => {
        if (typeof collection.fields === "string") {
          throw new Error("Global templates not supported");
        }
        const field = collection.fields.find((field2) => {
          if (typeof field2 === "string") {
            throw new Error("Global templates not supported");
          }
          return field2.name === key;
        });
        if (field) {
          accumulator[key] = this.transformField(field, value);
        }
      });
      return accumulator;
    };
    this.transformField = (field, value) => {
      if (field.type === "object")
        if (field.templates) {
          if (field.list) {
            assertShape(value, (yup2) => yup2.array(yup2.object({ _template: yup2.string().required() })));
            return value.map((item) => {
              const { _template, ...rest } = item;
              const template = field.templates.find((template2) => {
                if (typeof template2 === "string") {
                  return false;
                }
                return template2.name === _template;
              });
              if (typeof template === "string") {
                throw new Error("Global templates not supported");
              }
              return {
                [_template]: this.transformCollectablePayload(rest, template)
              };
            });
          } else {
            assertShape(value, (yup2) => yup2.object({ _template: yup2.string().required() }));
            const { _template, ...rest } = value;
            return { [_template]: this.transformCollectablePayload(rest, field) };
          }
        } else {
          if (field.list) {
            assertShape(value, (yup2) => yup2.array(yup2.object()));
            return value.map((item) => {
              return this.transformCollectablePayload(item, field);
            });
          } else {
            assertShape(value, (yup2) => yup2.object());
            return this.transformCollectablePayload(value, field);
          }
        }
      else {
        return value;
      }
    };
    this.isMarkdownCollection = (collectionName) => {
      const collection = this.getCollection(collectionName);
      const format = collection.format;
      if (!format) {
        return true;
      }
      if (["markdown", "md"].includes(format)) {
        return true;
      }
      return false;
    };
    this.getTemplatesForCollectable = (collection) => {
      let extraFields = [];
      if (collection.references) {
        extraFields = collection.references;
      }
      if (collection.fields) {
        const template = typeof collection.fields === "string" ? this.getGlobalTemplate(collection.fields) : collection;
        if (typeof template.fields === "string" || typeof template.fields === "undefined") {
          throw new Error("Exptected template to have fields but none were found");
        }
        return {
          namespace: collection.namespace,
          type: "object",
          template: {
            ...template,
            fields: [...template.fields, ...extraFields]
          }
        };
      } else {
        if (collection.templates) {
          return {
            namespace: collection.namespace,
            type: "union",
            templates: collection.templates.map((templateOrTemplateString) => {
              const template = typeof templateOrTemplateString === "string" ? this.getGlobalTemplate(templateOrTemplateString) : templateOrTemplateString;
              return {
                ...template,
                fields: [...template.fields, ...extraFields]
              };
            })
          };
        } else {
          throw new Error(`Expected either fields or templates array to be defined on collection ${collection.namespace.join("_")}`);
        }
      }
    };
    this.schema = config;
  }
}
const resolveField = (field, schema) => {
  var _a;
  field.parentTypename = NAMER.dataTypeName(field.namespace.filter((_, i) => i < field.namespace.length - 1));
  const extraFields = field.ui || {};
  switch (field.type) {
    case "number":
      return {
        component: "number",
        ...field,
        ...extraFields
      };
    case "datetime":
      return {
        component: "date",
        ...field,
        ...extraFields
      };
    case "boolean":
      return {
        component: "toggle",
        ...field,
        ...extraFields
      };
    case "image":
      return {
        component: "image",
        clearable: true,
        ...field,
        ...extraFields
      };
    case "string":
      if (field.options) {
        if (field.list) {
          return {
            component: "checkbox-group",
            ...field,
            ...extraFields,
            options: field.options
          };
        }
        if (field.options[0] && typeof field.options[0] === "object" && field.options[0].icon) {
          return {
            component: "button-toggle",
            ...field,
            ...extraFields,
            options: field.options
          };
        }
        return {
          component: "select",
          ...field,
          ...extraFields,
          options: field.ui && field.ui.component !== "select" ? field.options : [{ label: `Choose an option`, value: "" }, ...field.options]
        };
      }
      if (field.list) {
        return {
          component: "list",
          field: {
            component: "text"
          },
          ...field,
          ...extraFields
        };
      }
      return {
        component: "text",
        ...field,
        ...extraFields
      };
    case "object":
      const templateInfo = schema.getTemplatesForCollectable(field);
      if (templateInfo.type === "object") {
        return {
          ...field,
          component: field.list ? "group-list" : "group",
          fields: templateInfo.template.fields.map((field2) => resolveField(field2, schema)),
          ...extraFields
        };
      } else if (templateInfo.type === "union") {
        const templates2 = {};
        const typeMap2 = {};
        templateInfo.templates.forEach((template) => {
          const extraFields2 = template.ui || {};
          const templateName = lastItem(template.namespace);
          typeMap2[templateName] = NAMER.dataTypeName(template.namespace);
          templates2[lastItem(template.namespace)] = {
            label: template.label || templateName,
            key: templateName,
            namespace: [...field.namespace, templateName],
            fields: template.fields.map((field2) => resolveField(field2, schema)),
            ...extraFields2
          };
          return true;
        });
        return {
          ...field,
          typeMap: typeMap2,
          namespace: field.namespace,
          component: field.list ? "blocks" : "not-implemented",
          templates: templates2,
          ...extraFields
        };
      } else {
        throw new Error(`Unknown object for resolveField function`);
      }
    case "rich-text":
      const templates = {};
      (_a = field.templates) == null ? void 0 : _a.forEach((template) => {
        if (typeof template === "string") {
          throw new Error(`Global templates not yet supported for rich-text`);
        } else {
          const extraFields2 = template.ui || {};
          const templateName = lastItem(template.namespace);
          NAMER.dataTypeName(template.namespace);
          templates[lastItem(template.namespace)] = {
            label: template.label || templateName,
            key: templateName,
            inline: template.inline,
            name: templateName,
            match: template.match,
            fields: template.fields.map((field2) => resolveField(field2, schema)),
            ...extraFields2
          };
          return true;
        }
      });
      return {
        ...field,
        templates: Object.values(templates),
        component: "rich-text",
        ...extraFields
      };
    case "reference":
      return {
        ...field,
        component: "reference",
        ...extraFields
      };
    default:
      throw new Error(`Unknown field type ${field.type}`);
  }
};
const resolveForm = ({
  collection,
  basename,
  template,
  schema
}) => {
  return {
    id: basename,
    label: collection.label,
    name: basename,
    fields: template.fields.map((field) => {
      return resolveField(field, schema);
    })
  };
};
const parseZodError = ({ zodError }) => {
  var _a, _b, _c, _d;
  const errors = zodError.flatten((issue) => {
    const moreInfo = [];
    if (issue.code === "invalid_union") {
      issue.unionErrors.map((unionError) => {
        moreInfo.push(parseZodError({ zodError: unionError }));
      });
    }
    const errorMessage = `Error ${issue == null ? void 0 : issue.message} at path ${issue.path.join(".")}`;
    const errorMessages = [errorMessage, ...moreInfo];
    return {
      errors: errorMessages
    };
  });
  const formErrors = errors.formErrors.flatMap((x) => x.errors);
  const parsedErrors = [
    ...((_b = (_a = errors.fieldErrors) == null ? void 0 : _a.collections) == null ? void 0 : _b.flatMap((x) => x.errors)) || [],
    ...((_d = (_c = errors.fieldErrors) == null ? void 0 : _c.config) == null ? void 0 : _d.flatMap((x) => x.errors)) || [],
    ...formErrors
  ];
  return parsedErrors;
};
const name = z.string({
  required_error: "Name is required but not provided",
  invalid_type_error: "Name must be a string"
}).refine((val) => val.match(/^[a-zA-Z0-9_]*$/) !== null, (val) => ({
  message: `name, "${val}" must be alphanumeric and can only contain underscores`
}));
const TypeName = [
  "string",
  "boolean",
  "number",
  "datetime",
  "image",
  "object",
  "reference",
  "rich-text"
];
const typeTypeError = `type must be one of ${TypeName.join(", ")}`;
const typeRequiredError = `type is required and must be one of ${TypeName.join(", ")}`;
const nameProp = z.string({
  required_error: "name must be provided",
  invalid_type_error: "name must be a sting"
}).superRefine((val, ctx) => {
  if (val.includes(" "))
    ctx.addIssue({
      message: `name "${val}" cannot contain spaces`,
      code: z.ZodIssueCode.custom,
      fatal: true
    });
});
const Option = z.union([
  z.string(),
  z.object({ label: z.string(), value: z.string() }),
  z.object({ icon: z.any(), value: z.string() })
], {
  errorMap: () => {
    return {
      message: "Invalid option array. Must be a string[] or {label: string, value: string}[] or {icon: React.ComponentType<any>, value: string}[]"
    };
  }
});
const TinaField = z.object({
  name: nameProp,
  label: z.string().or(z.boolean()).optional(),
  description: z.string().optional(),
  required: z.boolean().optional()
});
const FieldWithList = TinaField.extend({ list: z.boolean().optional() });
const TinaScalerBase = FieldWithList.extend({
  options: z.array(Option).optional()
});
const StringField = TinaScalerBase.extend({
  type: z.literal("string", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  }),
  isTitle: z.boolean().optional()
});
const BooleanField = TinaScalerBase.extend({
  type: z.literal("boolean", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  })
});
const NumberField = TinaScalerBase.extend({
  type: z.literal("number", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  })
});
const ImageField = TinaScalerBase.extend({
  type: z.literal("image", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  })
});
const DateTimeField = TinaScalerBase.extend({
  type: z.literal("datetime", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  }),
  dateFormat: z.string().optional(),
  timeFormat: z.string().optional()
});
const ReferenceField = FieldWithList.extend({
  type: z.literal("reference", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  })
});
const TinaFieldZod = z.lazy(() => {
  const TemplateTemp = z.object({
    label: z.string().optional(),
    name: nameProp,
    fields: z.array(TinaFieldZod),
    match: z.object({
      start: z.string(),
      end: z.string(),
      name: z.string().optional()
    }).optional()
  }).superRefine((val, ctx) => {
    const dups = findDuplicates(val == null ? void 0 : val.fields.map((x) => x.name));
    if (dups) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `Fields must have a unique name, duplicate field names: ${dups}`
      });
    }
  });
  const ObjectField = FieldWithList.extend({
    type: z.literal("object", {
      invalid_type_error: typeTypeError,
      required_error: typeRequiredError
    }),
    fields: z.array(TinaFieldZod).min(1).optional().superRefine((val, ctx) => {
      const dups = findDuplicates(val == null ? void 0 : val.map((x) => x.name));
      if (dups) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Fields must have a unique name, duplicate field names: ${dups}`
        });
      }
    }),
    templates: z.array(TemplateTemp).min(1).optional().superRefine((val, ctx) => {
      const dups = findDuplicates(val == null ? void 0 : val.map((x) => x.name));
      if (dups) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Templates must have a unique name, duplicate template names: ${dups}`
        });
      }
    })
  });
  const RichTextField = FieldWithList.extend({
    type: z.literal("rich-text", {
      invalid_type_error: typeTypeError,
      required_error: typeRequiredError
    }),
    templates: z.array(TemplateTemp).optional().superRefine((val, ctx) => {
      const dups = findDuplicates(val == null ? void 0 : val.map((x) => x.name));
      if (dups) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Templates must have a unique name, duplicate template names: ${dups}`
        });
      }
    })
  });
  return z.discriminatedUnion("type", [
    StringField,
    BooleanField,
    NumberField,
    ImageField,
    DateTimeField,
    ReferenceField,
    ObjectField,
    RichTextField
  ], {
    errorMap: (issue, ctx) => {
      var _a;
      if (issue.code === "invalid_union_discriminator") {
        return {
          message: `Invalid \`type\` property. In the schema is 'type: ${(_a = ctx.data) == null ? void 0 : _a.type}' and expected one of ${TypeName.join(", ")}`
        };
      }
      return {
        message: issue.message
      };
    }
  }).superRefine((val, ctx) => {
    if (val.type === "string") {
      if (val.isTitle) {
        if (val.list) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: `Can not have \`list: true\` when using \`isTitle\`. Error in value 
${JSON.stringify(val, null, 2)}
`
          });
        }
        if (!val.required) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: `Must have { required: true } when using \`isTitle\` Error in value 
${JSON.stringify(val, null, 2)}
`
          });
        }
      }
    }
    if (val.type === "object") {
      const message = "Must provide one of templates or fields in your collection";
      let isValid = Boolean(val == null ? void 0 : val.templates) || Boolean(val == null ? void 0 : val.fields);
      if (!isValid) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message
        });
        return false;
      } else {
        isValid = !((val == null ? void 0 : val.templates) && (val == null ? void 0 : val.fields));
        if (!isValid) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message
          });
        }
        return isValid;
      }
    }
    return true;
  });
});
const tinaConfigKey = z$1.object({
  publicFolder: z$1.string(),
  mediaRoot: z$1.string()
}).strict().optional();
const tinaConfigZod = z$1.object({
  client: z$1.object({ referenceDepth: z$1.number().optional() }).optional(),
  media: z$1.object({
    tina: tinaConfigKey,
    loadCustomStore: z$1.function().optional()
  }).optional()
});
const validateTinaCloudSchemaConfig = (config) => {
  const newConfig = tinaConfigZod.parse(config);
  return newConfig;
};
const FORMATS = ["json", "md", "markdown", "mdx", "toml", "yaml"];
const Template = z.object({
  label: z.string({
    invalid_type_error: "label must be a string",
    required_error: "label was not provided but is required"
  }),
  name,
  fields: z.array(TinaFieldZod)
}).superRefine((val, ctx) => {
  var _a;
  const dups = findDuplicates((_a = val.fields) == null ? void 0 : _a.map((x) => x.name));
  if (dups) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: `Fields must have a unique name, duplicate field names: ${dups}`
    });
  }
});
const TinaCloudCollectionBase = z.object({
  label: z.string().optional(),
  name: name.superRefine((val, ctx) => {
    if (val === "relativePath") {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `name cannot be 'relativePath'. 'relativePath' is a reserved field name.`
      });
    }
  }),
  format: z.enum(FORMATS).optional()
});
const TinaCloudCollection = TinaCloudCollectionBase.extend({
  fields: z.array(TinaFieldZod).min(1).optional().superRefine((val, ctx) => {
    const dups = findDuplicates(val == null ? void 0 : val.map((x) => x.name));
    if (dups) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `Fields must have a unique name, duplicate field names: ${dups}`
      });
    }
  }).refine((val) => {
    const arr = (val == null ? void 0 : val.filter((x) => x.type === "string" && x.isTitle)) || [];
    return arr.length < 2;
  }, {
    message: "Fields can only have one use of `isTitle`"
  }),
  templates: z.array(Template).min(1).optional().superRefine((val, ctx) => {
    const dups = findDuplicates(val == null ? void 0 : val.map((x) => x.name));
    if (dups) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `Templates must have a unique name, duplicate template names: ${dups}`
      });
    }
  })
}).refine((val) => {
  let isValid = Boolean(val == null ? void 0 : val.templates) || Boolean(val == null ? void 0 : val.fields);
  if (!isValid) {
    return false;
  } else {
    isValid = !((val == null ? void 0 : val.templates) && (val == null ? void 0 : val.fields));
    return isValid;
  }
}, { message: "Must provide one of templates or fields in your collection" });
const TinaCloudSchemaZod = z.object({
  collections: z.array(TinaCloudCollection),
  config: tinaConfigZod.optional()
}).superRefine((val, ctx) => {
  var _a, _b;
  const dups = findDuplicates((_a = val.collections) == null ? void 0 : _a.map((x) => x.name));
  if (dups) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: `${dups} are duplicate names in your collections. Collection names must be unique.`,
      fatal: true
    });
  }
  const media = (_b = val == null ? void 0 : val.config) == null ? void 0 : _b.media;
  if (media && media.tina && media.loadCustomStore) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: "can not have both loadCustomStore and tina. Must use one or the other",
      fatal: true,
      path: ["config", "media"]
    });
  }
});
class TinaSchemaValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "TinaSchemaValidationError";
  }
}
const validateSchema = ({
  schema
}) => {
  try {
    TinaCloudSchemaZod.parse(schema);
  } catch (e) {
    if (e instanceof ZodError) {
      const errors = parseZodError({ zodError: e });
      throw new TinaSchemaValidationError(errors.join(", \n"));
    } else {
      throw new Error(e);
    }
  }
};
export { NAMER, TINA_HOST, TinaSchema, TinaSchemaValidationError, addNamespaceToSchema, parseURL, resolveField, resolveForm, validateSchema, validateTinaCloudSchemaConfig };
