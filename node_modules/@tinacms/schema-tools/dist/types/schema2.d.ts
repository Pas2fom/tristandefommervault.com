/**

*/
import { Option, UICollection } from './SchemaTypes';
/**
 * NOTE this is WIP - it's not being used but ideally
 * we can start to leverage it for the `defineStaticConfig`
 *
 * The current schema type defs are way more complex to be
 * user-facing. This schema also gets rid of stuff we didn't
 * get around to implementing like `templates: string` (which
 * were for global templates)
 *
 */
declare type FC<T> = (props: T) => unknown;
declare type UIField<Type> = {
    label?: string;
    description?: string;
    component?: FC<any> | string | null;
    parse?: (value: Type, name: string, field: Field) => any;
    format?: (value: Type, name: string, field: Field) => any;
    validate?(value: Type, allValues: any, meta: any): Type | undefined | void;
    /**
     * @deprecated use `defaultItem` at the collection level instead
     */
    defaultValue?: Type;
};
declare type FieldGeneric<Type> = {
    required: true;
    list: true;
    ui?: UIField<Type[]>;
} | {
    required: true;
    list?: false | undefined;
    ui?: UIField<Type>;
} | {
    required?: false | undefined;
    list: true;
    ui?: UIField<Type[] | undefined>;
} | {
    required?: false | undefined;
    list?: false | undefined;
    ui?: UIField<Type | undefined>;
};
declare type BaseField<Type, Ui extends object = undefined> = {
    name: string;
    label?: string;
    description?: string;
    ui?: Ui extends object ? UIField<Type> & Ui : UIField<Type>;
} & FieldGeneric<Type>;
declare type StringFieldBase = {
    type: 'string';
    /** Designate this field's value as the document title  */
    isTitle?: boolean;
    options?: Option[];
} & BaseField<string>;
declare type StringField = StringFieldBase & FieldGeneric<string>;
declare type NumberField = {
    type: 'number';
} & BaseField<number>;
declare type BooleanField = {
    type: 'boolean';
} & BaseField<boolean>;
declare type DateTimeField = {
    type: 'datetime';
} & BaseField<string>;
declare type ImageField = {
    type: 'image';
} & BaseField<string>;
declare type ReferenceField = {
    type: 'reference';
    collections: string[];
} & BaseField<string>;
declare type RichTextField = {
    type: 'rich-text';
    /**
     * For markdown or MDX formats, this value will be
     * saved to the document body
     */
    isBody?: boolean;
} & BaseField<object> & WithTemplates<true>;
declare type ObjectField = ({
    type: 'object';
} & BaseField<object, {
    itemProps?(item: Record<string, any>): {
        key?: string;
        label?: string;
    };
}>) & (WithFields | WithTemplates);
declare type Field = StringField | NumberField | BooleanField | DateTimeField | ImageField | ReferenceField | RichTextField | ObjectField;
declare type WithFields = {
    fields: Field[];
    templates?: never;
};
declare type Template = {
    name: string;
    label?: string;
    fields: Field[];
    match?: {
        start: string;
        end: string;
        name?: string;
    };
};
declare type WithTemplates<Optional extends boolean = false> = Optional extends true ? {
    templates?: Template[];
    fields?: never;
} : {
    templates: Template[];
    fields?: never;
};
declare type TinaCMSCollection = {
    label?: string;
    name: string;
    path: string;
    format?: 'json' | 'md' | 'markdown' | 'mdx';
    match?: string;
    ui?: UICollection;
} & (WithTemplates | WithFields);
/**
 * @deprecated use TinaCMSSchema instead
 */
export declare type TinaCloudSchema = TinaCMSSchema;
export declare type TinaCMSSchema = {
    collections: TinaCMSCollection[];
};
export {};
