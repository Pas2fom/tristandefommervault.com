import { useCMS, Form, GlobalFormPlugin, EventBus, Modal, ModalPopup, ModalHeader, ModalBody, ModalActions, Button, LoadingDots, useLocalStorage, TinaCMS, BranchSwitcherPlugin, BranchDataProvider, TinaProvider, TinaMediaStore, DummyMediaStore, Nav, LocalWarning, BillingWarning, Select, Input, ReactDateTimeWithStyles, textFieldClasses, Toggle, OverflowMenu, CursorPaginator, PopupModal, BaseTextField, wrapFieldsWithMeta, FormStatus, FormBuilder } from "@tinacms/toolkit";
export * from "@tinacms/toolkit";
export { MdxFieldPluginExtendible } from "@tinacms/toolkit";
import * as G from "graphql";
import { TypeInfo, visit, visitWithTypeInfo, getNamedType, GraphQLObjectType, isLeafType, GraphQLUnionType, isScalarType as isScalarType$1, getIntrospectionQuery, buildClientSchema, print, parse } from "graphql";
import set from "lodash.set";
import React, { useState, useCallback, useEffect, Fragment, useMemo } from "react";
import { getIn, setIn } from "final-form";
import { resolveForm, TinaSchema, addNamespaceToSchema, parseURL, validateSchema } from "@tinacms/schema-tools";
export { NAMER, resolveForm } from "@tinacms/schema-tools";
import gql$1 from "graphql-tag";
import * as yup from "yup";
import { setEditing, TinaDataContext, EditContext, useEditState } from "@tinacms/sharedctx";
import { NavLink, useSearchParams, useNavigate, useParams, useLocation, Link, HashRouter, Routes, Route } from "react-router-dom";
import { Transition, Menu } from "@headlessui/react";
import { useWindowWidth } from "@react-hook/window-size";
function popupWindow(url, title, window2, w, h) {
  const y = window2.top.outerHeight / 2 + window2.top.screenY - h / 2;
  const x = window2.top.outerWidth / 2 + window2.top.screenX - w / 2;
  return window2.open(url, title, "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes, copyhistory=no, width=" + w + ", height=" + h + ", top=" + y + ", left=" + x);
}
const TINA_LOGIN_EVENT = "tinaCloudLogin";
const AUTH_TOKEN_KEY = "tinacms-auth";
const authenticate = (clientId, frontendUrl) => {
  return new Promise((resolve) => {
    let authTab;
    window.addEventListener("message", function(e) {
      if (e.data.source === TINA_LOGIN_EVENT) {
        if (authTab) {
          authTab.close();
        }
        resolve({
          id_token: e.data.id_token,
          access_token: e.data.access_token,
          refresh_token: e.data.refresh_token
        });
      }
    });
    const origin = `${window.location.protocol}//${window.location.host}`;
    authTab = popupWindow(`${frontendUrl}/signin?clientId=${clientId}&origin=${origin}`, "_blank", window, 1e3, 700);
  });
};
const formify$1 = (query, schema) => {
  const typeInfo = new TypeInfo(schema);
  const pathsToPopulate = [];
  const visitor = {
    leave(node2, key, parent, path, ancestors) {
      const type = typeInfo.getType();
      if (type) {
        const namedType = getNamedType(type);
        if (namedType instanceof GraphQLObjectType) {
          const hasNodeInterface = !!namedType.getInterfaces().find((i) => i.name === "Node");
          if (hasNodeInterface) {
            if (typeof path[path.length - 1] === "number") {
              assertIsObjectType(namedType);
              const valuesNode = namedType.getFields().values;
              const namedValuesNode = getNamedType(valuesNode.type);
              const pathForValues = [...path];
              pathForValues.push("selectionSet");
              pathForValues.push("selections");
              const valuesAst = buildValuesForType(namedValuesNode);
              pathForValues.push(100);
              const formNode = namedType.getFields().form;
              const namedFormNode = getNamedType(formNode.type);
              const pathForForm = [...path];
              pathForForm.push("selectionSet");
              pathForForm.push("selections");
              const formAst = buildFormForType(namedFormNode);
              pathForForm.push(101);
              const sysNode = namedType.getFields().sys;
              const namedSysNode = getNamedType(sysNode.type);
              const pathForSys = [...path];
              pathForSys.push("selectionSet");
              pathForSys.push("selections");
              const sysAst = buildSysForType(namedSysNode);
              pathForSys.push(102);
              pathsToPopulate.push({
                path: path.map((p) => p.toString()).join("-"),
                paths: [
                  {
                    path: pathForValues.map((p) => p.toString()),
                    ast: valuesAst
                  },
                  {
                    path: pathForForm.map((p) => p.toString()),
                    ast: formAst
                  },
                  {
                    path: pathForSys.map((p) => p.toString()),
                    ast: sysAst
                  }
                ]
              });
            }
          }
        }
      }
    }
  };
  visit(query, visitWithTypeInfo(typeInfo, visitor));
  const topLevelPaths = pathsToPopulate.filter((p, i) => {
    const otherPaths = pathsToPopulate.filter((_, index) => index !== i);
    const isChildOfOtherPaths = otherPaths.some((op) => {
      if (p.path.startsWith(op.path)) {
        return true;
      } else {
        return false;
      }
    });
    if (isChildOfOtherPaths) {
      return false;
    } else {
      return true;
    }
  });
  topLevelPaths.map((p) => {
    p.paths.map((pathNode) => {
      set(query, pathNode.path, pathNode.ast);
    });
  });
  return query;
};
const buildSysForType = (type) => {
  assertIsObjectType(type);
  return {
    kind: "Field",
    alias: {
      kind: "Name",
      value: "_internalSys"
    },
    name: {
      kind: "Name",
      value: "sys"
    },
    selectionSet: {
      kind: "SelectionSet",
      selections: buildSelectionsFields(Object.values(type.getFields()), (fields) => {
        return {
          continue: true,
          filteredFields: fields.filter((field) => field.name !== "documents")
        };
      })
    }
  };
};
const buildValuesForType = (type) => {
  try {
    assertIsUnionType(type);
    return {
      kind: "Field",
      name: {
        kind: "Name",
        value: "values"
      },
      selectionSet: {
        kind: "SelectionSet",
        selections: buildSelectionInlineFragments(type.getTypes())
      }
    };
  } catch (e) {
    return {
      kind: "Field",
      name: {
        kind: "Name",
        value: "values"
      }
    };
  }
};
const buildFormForType = (type) => {
  try {
    assertIsUnionType(type);
    return {
      kind: "Field",
      name: {
        kind: "Name",
        value: "form"
      },
      selectionSet: {
        kind: "SelectionSet",
        selections: buildSelectionInlineFragments(type.getTypes())
      }
    };
  } catch (e) {
    return {
      kind: "Field",
      name: {
        kind: "Name",
        value: "form"
      }
    };
  }
};
const buildSelectionInlineFragments = (types, callback) => {
  return types.map((type) => {
    return {
      kind: "InlineFragment",
      typeCondition: {
        kind: "NamedType",
        name: {
          kind: "Name",
          value: type.name
        }
      },
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          ...Object.values(type.getFields()).map((field) => {
            const namedType = getNamedType(field.type);
            if (isLeafType(namedType)) {
              return {
                kind: "Field",
                name: {
                  kind: "Name",
                  value: field.name
                }
              };
            } else if (namedType instanceof GraphQLUnionType) {
              return {
                kind: "Field",
                name: {
                  kind: "Name",
                  value: field.name
                },
                selectionSet: {
                  kind: "SelectionSet",
                  selections: [
                    ...buildSelectionInlineFragments(namedType.getTypes(), callback)
                  ]
                }
              };
            } else if (namedType instanceof GraphQLObjectType) {
              return {
                kind: "Field",
                name: {
                  kind: "Name",
                  value: field.name
                },
                selectionSet: {
                  kind: "SelectionSet",
                  selections: [
                    ...buildSelectionsFields(Object.values(namedType.getFields()), callback)
                  ]
                }
              };
            } else {
              throw new Error(`Unexpected GraphQL type for field ${namedType.name}`);
            }
          })
        ]
      }
    };
  });
};
const buildSelectionsFields = (fields, callback) => {
  let filteredFields = fields;
  if (callback) {
    const result = callback(fields);
    if (!result.continue) {
      if (fields.every((field) => {
        return !isScalarType$1(getNamedType(field.type));
      })) {
        return [
          {
            kind: "Field",
            name: {
              kind: "Name",
              value: "__typename"
            }
          }
        ];
      }
      return buildSelectionsFields(result.filteredFields.filter((field) => {
        if (isScalarType$1(getNamedType(field.type))) {
          return true;
        }
        return false;
      }));
    } else {
      filteredFields = result.filteredFields;
    }
  }
  return filteredFields.map((field) => {
    const namedType = getNamedType(field.type);
    if (isLeafType(namedType)) {
      return {
        kind: "Field",
        name: {
          kind: "Name",
          value: field.name
        }
      };
    } else if (namedType instanceof GraphQLUnionType) {
      return {
        kind: "Field",
        name: {
          kind: "Name",
          value: field.name
        },
        selectionSet: {
          kind: "SelectionSet",
          selections: [
            ...buildSelectionInlineFragments(namedType.getTypes(), callback)
          ]
        }
      };
    } else if (namedType instanceof GraphQLObjectType) {
      return {
        kind: "Field",
        name: {
          kind: "Name",
          value: field.name
        },
        selectionSet: {
          kind: "SelectionSet",
          selections: [
            ...buildSelectionsFields(Object.values(namedType.getFields()), callback)
          ]
        }
      };
    } else {
      return {
        kind: "Field",
        name: {
          kind: "Name",
          value: field.name
        },
        selectionSet: {
          kind: "SelectionSet",
          selections: []
        }
      };
    }
  });
};
function assertIsObjectType(type) {
  if (type instanceof GraphQLObjectType)
    ;
  else {
    throw new Error(`Expected an instance of GraphQLObjectType for type ${type.name}`);
  }
}
function assertIsUnionType(type) {
  if (type instanceof GraphQLUnionType)
    ;
  else {
    throw new Error(`Expected an instance of GraphQLUnionType for type ${type.name}`);
  }
}
const createClient = ({
  clientId,
  isLocalClient = true,
  branch,
  tinaioConfig,
  schema,
  apiUrl
}) => {
  return isLocalClient ? new LocalClient({ customContentApiUrl: apiUrl, schema }) : new Client({
    clientId: clientId || "",
    branch: branch || "main",
    tokenStorage: "LOCAL_STORAGE",
    tinaioConfig,
    schema
  });
};
function assertShape(value, yupSchema, errorMessage) {
  const shape = yupSchema(yup);
  try {
    shape.validateSync(value);
  } catch (e) {
    const message = errorMessage || `Failed to assertShape - ${e.message}`;
    throw new Error(message);
  }
}
function safeAssertShape(value, yupSchema) {
  try {
    assertShape(value, yupSchema);
    return true;
  } catch (e) {
    return false;
  }
}
function useGraphqlForms({
  variables,
  onSubmit,
  query,
  formify: formify2,
  eventList
}) {
  const cms = useCMS();
  const state = useFormify({
    query,
    cms,
    variables,
    formify: formify2,
    eventList,
    onSubmit
  });
  if (!query) {
    return [state.data, false];
  }
  return [state.data, state.status !== "done"];
}
const transformDocumentIntoMutationRequestPayload = (document, instructions) => {
  const { _collection, __typename, _template, ...rest } = document;
  const params = transformParams(rest);
  const paramsWithTemplate = instructions.includeTemplate ? { [_template]: params } : params;
  return instructions.includeCollection ? { [_collection]: paramsWithTemplate } : paramsWithTemplate;
};
const transformParams = (data) => {
  if (["string", "number", "boolean"].includes(typeof data)) {
    return data;
  }
  if (Array.isArray(data)) {
    return data.map((item) => transformParams(item));
  }
  try {
    assertShape(data, (yup2) => yup2.object({ _template: yup2.string().required() }));
    const { _template, __typename, ...rest } = data;
    const nested = transformParams(rest);
    return { [_template]: nested };
  } catch (e) {
    if (e.message === "Failed to assertShape - _template is a required field") {
      if (!data) {
        return [];
      }
      const accum = {};
      Object.entries(data).map(([keyName, value]) => {
        accum[keyName] = transformParams(value);
      });
      return accum;
    } else {
      if (!data) {
        return [];
      }
      throw e;
    }
  }
};
const generateFormCreators = (cms, showInSidebar, global) => {
  const createForm = (formConfig) => {
    const form = new Form(formConfig);
    if (showInSidebar) {
      if (global) {
        const options = typeof global === "boolean" ? [null, "fullscreen"] : [global.icon, global.layout];
        cms.plugins.add(new GlobalFormPlugin(form, ...options));
      } else {
        cms.forms.add(form);
      }
    }
    return form;
  };
  const createGlobalForm = (formConfig, options) => {
    const form = new Form(formConfig);
    if (showInSidebar) {
      cms.plugins.add(new GlobalFormPlugin(form, options == null ? void 0 : options.icon, options == null ? void 0 : options.layout));
    }
    return form;
  };
  return { createForm, createGlobalForm };
};
const getValueForBlueprint = (state, path) => {
  const pathArray = path.split(".");
  let latest = state;
  pathArray.every((item, index) => {
    if (item === "[]") {
      const restOfItems = pathArray.slice(index + 1);
      if (latest) {
        const next = [];
        if (Array.isArray(latest)) {
          latest.forEach((latest2, index2) => {
            const res = getValueForBlueprint(latest2, restOfItems.join("."));
            next.push(res);
          });
        } else {
          throw new Error(`Expected value to be an array for "[]" item`);
        }
        if (next.length > 0) {
          latest = next;
        } else {
          latest = void 0;
        }
      }
      return false;
    } else {
      if (latest) {
        latest = latest[item];
      } else {
        latest = void 0;
      }
    }
    return true;
  });
  return latest;
};
const getFieldNameOrAlias = (fieldBlueprint) => {
  return fieldBlueprint.path[fieldBlueprint.path.length - 1].alias;
};
const spliceLocation = (string, location) => {
  const accum = [];
  let counter = 0;
  string.split(".").forEach((item) => {
    if (item === "[]") {
      accum.push(location[counter]);
      counter++;
    } else {
      accum.push(item);
    }
  });
  return accum.join(".");
};
const getPathToChange = (documentBlueprint, formNode, event) => {
  const fieldName = event.field.name;
  const location = [...formNode.location, ...stripIndices(fieldName)];
  const accum = [];
  let counter = 0;
  documentBlueprint.path.forEach((item) => {
    accum.push(item.alias);
    if (item.list) {
      if (location[counter] !== void 0) {
        accum.push(location[counter]);
        counter++;
      }
    }
  });
  return accum.join(".");
};
const buildForm = (doc, cms, formify2, showInSidebar = false, onSubmit) => {
  var _a;
  const id = doc._internalSys.path;
  const enrichedSchema = cms.api.tina.schema;
  const collection = enrichedSchema.getCollection(doc._internalSys.collection.name);
  const { createForm, createGlobalForm } = generateFormCreators(cms, showInSidebar, (_a = collection.ui) == null ? void 0 : _a.global);
  const SKIPPED = "SKIPPED";
  let form;
  let skipped;
  const skip = () => {
    skipped = SKIPPED;
  };
  if (skipped)
    return;
  const template = enrichedSchema.getTemplateForData({
    collection,
    data: doc._values
  });
  const formCommon = {
    id,
    label: id,
    initialValues: doc._values,
    onSubmit: async (payload) => {
      try {
        const params = transformDocumentIntoMutationRequestPayload(payload, {
          includeCollection: false,
          includeTemplate: !!collection.templates
        });
        const variables = { params };
        const mutationString = `#graphql
          mutation UpdateDocument($collection: String!, $relativePath: String!, $params: DocumentUpdateMutation!) {
            updateDocument(collection: $collection, relativePath: $relativePath, params: $params) {
              __typename
            }
          }
        `;
        if (onSubmit) {
          onSubmit({
            queryString: mutationString,
            mutationString,
            variables: {
              collection: doc._internalSys.collection.name,
              relativePath: doc._internalSys.relativePath,
              params: { [doc._internalSys.collection.name]: variables }
            }
          });
        } else {
          try {
            await cms.api.tina.request(mutationString, {
              variables: {
                collection: doc._internalSys.collection.name,
                relativePath: doc._internalSys.relativePath,
                params: {
                  [doc._internalSys.collection.name]: variables.params
                }
              }
            });
            cms.alerts.success("Document saved!");
          } catch (e) {
            cms.alerts.error("There was a problem saving your document.");
            console.error(e);
          }
        }
      } catch (e) {
        console.error(e);
        cms.alerts.error("There was a problem saving your document.");
      }
    }
  };
  let formConfig = {};
  const formInfo = resolveForm({
    collection,
    basename: collection.name,
    schema: enrichedSchema,
    template
  });
  formConfig = {
    label: formInfo.label,
    fields: formInfo.fields,
    ...formCommon
  };
  if (formify2) {
    form = formify2({
      formConfig,
      createForm,
      createGlobalForm,
      skip
    }, cms);
  } else {
    form = createForm(formConfig);
  }
  if (!(form instanceof Form)) {
    if (skipped === SKIPPED) {
      return;
    }
    throw new Error("formify must return a form or skip()");
  }
  return form;
};
const formNodeId = (formNode) => {
  return spliceLocation(formNode.documentBlueprintId, formNode.location) + formNode.documentFormId;
};
const formNodePath = (formNode) => {
  return spliceLocation(formNode.documentBlueprintId, formNode.location);
};
const formNodeNotIn = (formNode, formNodes) => {
  return !formNodes.find((fn) => formNodeId(fn) === formNodeId(formNode));
};
const sequential = async (items, callback) => {
  const accum = [];
  if (!items) {
    return [];
  }
  const reducePromises = async (previous, endpoint) => {
    const prev = await previous;
    if (prev) {
      accum.push(prev);
    }
    return callback(endpoint, accum.length);
  };
  const result = await items.reduce(reducePromises, Promise.resolve());
  if (result) {
    accum.push(result);
  }
  return accum;
};
const getFormNodesStartingWith = (string, state) => {
  return state.formNodes.filter((subFormNode) => {
    return subFormNode.documentBlueprintId.startsWith(string);
  });
};
const getFormNodesForField = (fieldBlueprint, formNode, event, state) => {
  const pathToChange = getPathToChange(fieldBlueprint, formNode, event);
  const formNodes = getFormNodesStartingWith(fieldBlueprint.id, state);
  const eventLocation = [
    ...formNode.location,
    ...stripIndices(event.field.name)
  ];
  const existing = getIn(state.data, pathToChange);
  return { pathToChange, formNodes, eventLocation, existing };
};
const getBlueprintAliasPath = (blueprint) => {
  const namePath = [];
  const aliasPath = [];
  blueprint.path.forEach((p) => {
    namePath.push(p.name);
    aliasPath.push(p.alias);
    if (p.list) {
      namePath.push("[]");
      aliasPath.push("[]");
    }
  });
  return aliasPath.join(".");
};
const getBlueprintFieldsForEvent = (blueprint, event) => {
  return blueprint.fields.filter((fbp) => {
    if (getBlueprintNamePath(fbp) === getEventPath(event, blueprint)) {
      return true;
    }
  }).filter((fbp) => {
    return filterFieldBlueprintsByParentTypename(fbp, event.field.data.tinaField.parentTypename);
  });
};
const filterFieldBlueprintsByParentTypename = (fbp, typename) => {
  let lastDisambiguator;
  fbp.path.forEach((path) => {
    if (path.parentTypename) {
      lastDisambiguator = path.parentTypename;
    }
  });
  if (lastDisambiguator) {
    return typename === lastDisambiguator;
  } else {
    return true;
  }
};
const getBlueprintNamePath = (blueprint, disambiguator) => {
  const namePath = [];
  blueprint.path.forEach((p) => {
    if (disambiguator) {
      if (p.parentTypename) {
        namePath.push(p.parentTypename);
      }
    }
    namePath.push(p.name);
    if (p.list) {
      namePath.push("[]");
    }
  });
  return namePath.join(".");
};
const getEventPath = (event, blueprint) => {
  const stringArray = event.field.name.split(".");
  const eventPath = stringArray.map((item) => {
    if (isNaN(Number(item))) {
      return item;
    }
    return `[]`;
  }).join(".");
  const items = [blueprint.id, eventPath];
  const isList = event.field.data.tinaField.list;
  if (isList && !eventPath.endsWith("[]")) {
    items.push(`[]`);
  }
  return items.join(".");
};
const stripIndices = (string) => {
  const accum = [];
  const stringArray = string.split(".");
  stringArray.forEach((item) => {
    if (isNaN(item))
      ;
    else {
      accum.push(Number(item));
    }
  });
  return accum;
};
const replaceRealNum = (string) => {
  const stringArray = string.split(".");
  return stringArray.map((item) => {
    if (isNaN(item)) {
      return item;
    }
    return "[]";
  }).join(".");
};
const getMatchName = ({ field, prefix, blueprint }) => {
  const fieldName = field.list ? `${field.name}.[]` : field.name;
  const blueprintName = getBlueprintNamePath(blueprint);
  const extra = [];
  if (prefix) {
    extra.push(prefix);
  }
  const matchName = [blueprintName, ...extra, fieldName].join(".");
  return { matchName, fieldName };
};
const getFormNodesFromEvent = (state, event) => {
  const formNodes = state.formNodes.filter((formNode) => formNode.documentFormId === event.formId);
  return formNodes;
};
const printEvent = (event) => {
  var _a, _b;
  return {
    type: event.type,
    value: event.value,
    previousValue: event.previousValue,
    mutationType: event.mutationType,
    formId: event.formId,
    field: {
      data: (_a = event.field) == null ? void 0 : _a.data,
      name: (_b = event.field) == null ? void 0 : _b.name
    }
  };
};
const getFormNodeBlueprint = (formNode, state) => {
  return state.blueprints.find((d) => d.id === formNode.documentBlueprintId);
};
const getMoveMapping = (existing, from, to) => {
  const newOrderObject = {};
  if (from < to) {
    existing.map((_, i) => {
      if (i === from) {
        newOrderObject[i] = to;
        return;
      }
      if (i > from) {
        if (i < to) {
          newOrderObject[i] = i - 1;
          return;
        } else {
          if (i === to) {
            newOrderObject[i] = i - 1;
            return;
          }
          newOrderObject[i] = i;
          return;
        }
      } else {
        newOrderObject[i] = i;
        return;
      }
    });
  } else {
    existing.map((_, i) => {
      if (i === from) {
        newOrderObject[i] = to;
        return;
      }
      if (i > to) {
        if (i < from) {
          newOrderObject[i] = i + 1;
          return;
        } else {
          newOrderObject[i] = i;
          return;
        }
      } else {
        if (i === to) {
          newOrderObject[i] = i + 1;
          return;
        }
        newOrderObject[i] = i;
        return;
      }
    });
  }
  return newOrderObject;
};
const matchLocation = (eventLocation, formNode) => {
  return eventLocation.every((item, index) => item === formNode.location[index]);
};
const bumpLocation = (location) => {
  return location.map((item, index) => {
    if (index === location.length - 1) {
      return item + 1;
    }
    return item;
  });
};
const maybeLowerLocation = (location, at) => {
  return location.map((item, index) => {
    if (index === location.length - 1) {
      return item < at ? item : item - 1;
    }
    return item;
  });
};
const matchesAt = (location, at) => {
  let matches = false;
  location.map((item, index) => {
    if (index === location.length - 1) {
      if (item === at) {
        matches = true;
      }
    }
  });
  return matches;
};
const swapLocation = (location, mapping) => {
  return location.map((item, index) => {
    if (index === location.length - 1) {
      return mapping[item];
    }
    return item;
  });
};
const getSubFields = (changeSet) => {
  var _a;
  const fields = changeSet.fieldDefinition.fields ? changeSet.fieldDefinition.fields : changeSet.fieldDefinition.templates[changeSet.value[0]._template].fields;
  let __typename;
  if ((_a = changeSet.fieldDefinition) == null ? void 0 : _a.templates) {
    __typename = changeSet.fieldDefinition.typeMap[changeSet.value[0]._template];
  }
  return { fields, __typename };
};
const isFormifiableDocument = (t) => {
  const type = G.getNamedType(t);
  if (G.isUnionType(type)) {
    return type.getTypes().every((type2) => {
      return type2.getInterfaces().find((intfc) => intfc.name === "Node");
    });
  } else if (G.isObjectType(type)) {
    return !!type.getInterfaces().find((intfc) => intfc.name === "Node");
  } else {
    return false;
  }
};
const isScalarType = (t) => {
  const namedType = G.getNamedType(t);
  return G.isScalarType(namedType);
};
const isConnectionField = (t) => {
  const type = G.getNamedType(t);
  if (G.isObjectType(type)) {
    return !!type.getInterfaces().find((intfc) => intfc.name === "Connection");
  } else {
    throw new Error(`Expected GraphQLObjectType for isConnectionField check`);
  }
};
const getObjectField = (object, selectionNode) => {
  const namedType = G.getNamedType(object);
  ensureObjectOrInterfaceType(namedType);
  return namedType.getFields()[selectionNode.name.value];
};
const getSelectedUnionType = (unionType, selectionNode) => {
  const namedType = G.getNamedType(unionType);
  if (!G.isUnionType(namedType)) {
    return;
  }
  const types = namedType.getTypes();
  const typeCondition = selectionNode.typeCondition.name.value;
  let intfc;
  types.forEach((type) => {
    intfc = type.getInterfaces().find((intfc2) => intfc2.name === typeCondition);
  });
  if (intfc) {
    return intfc;
  }
  return namedType.getTypes().find((type) => type.name === typeCondition);
};
function isListType(type) {
  if (G.isListType(type)) {
    return true;
  } else if (G.isNonNullType(type)) {
    if (G.isListType(type.ofType)) {
      return true;
    }
  }
  return false;
}
function ensureObjectOrInterfaceType(type) {
  if (G.isInterfaceType(type) || G.isObjectType(type))
    ;
  else {
    console.log("Expected type to be GraphQLObjectType or GraphQLInterfaceType", type);
    throw new Error(`Expected type to be GraphQLObjectType or GraphQLInterfaceType`);
  }
}
function ensureOperationDefinition(type) {
  if (type.kind !== "OperationDefinition") {
    throw new Error(`Expected top-level definition to be an OperationDefinition node, ensure your query has been optimized before calling formify`);
  }
}
function buildPath({
  fieldNode,
  type,
  parentTypename,
  path
}) {
  const p = path || [];
  const list = isListType(type);
  const isNode = isFormifiableDocument(type);
  return [
    ...p,
    {
      name: fieldNode.name.value,
      alias: fieldNode.alias ? fieldNode.alias.value : fieldNode.name.value,
      parentTypename,
      list: !!list,
      isNode: !!isNode
    }
  ];
}
const node = G.parse(`
 query Sample {
  ...on Document {
    _internalSys: _sys {
      path
      relativePath
      collection {
        name
      }
    }
    _values
  }
 }`);
const metaFields = node.definitions[0].selectionSet.selections;
const getRelativeBlueprint = (path) => {
  let indexOfLastNode = 0;
  path.forEach((item, i) => {
    if (item.isNode) {
      if (i === path.length - 1)
        ;
      else {
        indexOfLastNode = i;
      }
    }
  });
  const documentBlueprintPath = path.slice(0, indexOfLastNode + 1);
  return getBlueprintNamePath({ path: documentBlueprintPath });
};
const isSysField = (fieldNode) => {
  if (fieldNode.name.value === "__typename") {
    return true;
  }
  if (fieldNode.name.value === "_sys") {
    return true;
  }
  if (fieldNode.name.value === "_values") {
    return true;
  }
  if (fieldNode.name.value === "id") {
    return true;
  }
  return false;
};
const getBlueprintId = (path) => {
  const namePath = [];
  const aliasPath = [];
  path.forEach((p) => {
    namePath.push(p.name);
    aliasPath.push(p.alias);
    if (p.list) {
      namePath.push("[]");
      aliasPath.push("[]");
    }
  });
  return namePath.join(".");
};
const NOOP = "This is either an error or is not yet supported";
const UNEXPECTED = "Formify encountered an unexpected error, please contact support";
const EDGES_NODE_NAME = "edges";
const NODE_NAME = "node";
const COLLECTION_FIELD_NAME = "collection";
const COLLECTIONS_FIELD_NAME = "collections";
const COLLECTIONS_DOCUMENTS_NAME = "documents";
const formify = async ({
  schema,
  query,
  getOptimizedQuery
}) => {
  const blueprints = [];
  const documentNode = G.parse(query);
  const visitor = {
    OperationDefinition: (node2) => {
      if (!node2.name) {
        return {
          ...node2,
          name: {
            kind: "Name",
            value: `QueryOperation`
          }
        };
      }
      return node2;
    }
  };
  const documentNodeWithName = G.visit(documentNode, visitor);
  const optimizedQuery = await getOptimizedQuery(documentNodeWithName);
  const typeInfo = new G.TypeInfo(schema);
  const formifyConnection = ({
    parentType,
    selectionNode,
    path
  }) => {
    return {
      ...selectionNode,
      selectionSet: {
        kind: "SelectionSet",
        selections: selectionNode.selectionSet.selections.map((selectionNode2) => {
          switch (selectionNode2.kind) {
            case "Field":
              if (selectionNode2.name.value === EDGES_NODE_NAME) {
                const edgeField = getObjectField(parentType, selectionNode2);
                const edgesPath = buildPath({
                  fieldNode: selectionNode2,
                  type: edgeField.type,
                  path
                });
                return {
                  ...selectionNode2,
                  selectionSet: {
                    kind: "SelectionSet",
                    selections: selectionNode2.selectionSet.selections.map((subSelectionNode) => {
                      switch (subSelectionNode.kind) {
                        case "Field":
                          if (subSelectionNode.name.value === NODE_NAME) {
                            const nodeField = getObjectField(edgeField.type, subSelectionNode);
                            return formifyFieldNodeDocument({
                              fieldNode: subSelectionNode,
                              type: nodeField.type,
                              path: buildPath({
                                fieldNode: subSelectionNode,
                                type: nodeField.type,
                                path: edgesPath
                              }),
                              showInSidebar: false
                            });
                          } else {
                            return subSelectionNode;
                          }
                        default:
                          throw new FormifyError("NOOP");
                      }
                    })
                  }
                };
              }
              return selectionNode2;
            default:
              throw new FormifyError("UNEXPECTED");
          }
        })
      }
    };
  };
  function formifyInlineFragmentDocument({
    inlineFragmentNode,
    type,
    path,
    showInSidebar = false
  }) {
    return formifyDocument({
      selection: inlineFragmentNode,
      type,
      path,
      showInSidebar
    });
  }
  function formifyFieldNodeDocument({
    fieldNode,
    type,
    path,
    showInSidebar = false
  }) {
    return formifyDocument({ selection: fieldNode, type, path, showInSidebar });
  }
  function formifyDocument({
    selection,
    type,
    path,
    showInSidebar = false
  }) {
    let extraFields = [];
    const hasDataJSONField = false;
    let hasValuesField = false;
    let shouldFormify = false;
    selection.selectionSet.selections.forEach((selection2) => {
      if (selection2.kind === "Field") {
        shouldFormify = true;
        if (selection2.name.value === "_values") {
          hasValuesField = true;
        }
      }
    });
    if (shouldFormify) {
      blueprints.push({
        id: getBlueprintId(path),
        path,
        selection,
        fields: [],
        showInSidebar,
        hasDataJSONField,
        hasValuesField
      });
      extraFields = metaFields;
    }
    return {
      ...selection,
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          ...selection.selectionSet.selections.map((selectionNode) => {
            switch (selectionNode.kind) {
              case "InlineFragment": {
                const namedType = G.getNamedType(type);
                if (G.isInterfaceType(namedType)) {
                  const subType = schema.getImplementations(namedType).objects.find((item) => item.name === selectionNode.typeCondition.name.value);
                  return formifyInlineFragmentDocument({
                    inlineFragmentNode: selectionNode,
                    type: subType,
                    path,
                    showInSidebar: true
                  });
                }
                return formifyInlineFragmentNode({
                  inlineFragmentNode: selectionNode,
                  parentType: type,
                  path,
                  showInSidebar: true
                });
              }
              case "Field": {
                return formifyFieldNode({
                  fieldNode: selectionNode,
                  parentType: type,
                  path
                });
              }
              default:
                throw new FormifyError("UNEXPECTED");
            }
          }),
          ...extraFields
        ]
      }
    };
  }
  const formifyFieldNode = ({
    fieldNode,
    parentType,
    path
  }) => {
    if (fieldNode.name.value === "__typename") {
      return fieldNode;
    }
    const field = getObjectField(parentType, fieldNode);
    if (!field) {
      return fieldNode;
    }
    const fieldPath = buildPath({
      fieldNode,
      type: field.type,
      parentTypename: G.getNamedType(parentType).name,
      path
    });
    const blueprint = blueprints.find((blueprint2) => blueprint2.id === getRelativeBlueprint(fieldPath));
    if (!blueprint) {
      return fieldNode;
    }
    if (isSysField(fieldNode)) {
      return fieldNode;
    }
    blueprint.fields.push({
      id: getBlueprintId(fieldPath),
      documentBlueprintId: blueprint.id,
      path: fieldPath
    });
    if (isScalarType(field.type)) {
      return fieldNode;
    }
    return {
      ...fieldNode,
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          ...fieldNode.selectionSet.selections.map((selectionNode) => {
            switch (selectionNode.kind) {
              case "Field": {
                return formifyFieldNode({
                  fieldNode: selectionNode,
                  parentType: field.type,
                  path: fieldPath
                });
              }
              case "InlineFragment": {
                return formifyInlineFragmentNode({
                  inlineFragmentNode: selectionNode,
                  parentType: field.type,
                  path: fieldPath,
                  showInSidebar: false
                });
              }
              default:
                throw new FormifyError("UNEXPECTED", `selection ${selectionNode.kind}`);
            }
          })
        ]
      }
    };
  };
  const formifyInlineFragmentNode = ({
    inlineFragmentNode,
    parentType,
    path,
    showInSidebar
  }) => {
    const type = getSelectedUnionType(parentType, inlineFragmentNode);
    if (!type) {
      return inlineFragmentNode;
    }
    if (isFormifiableDocument(type)) {
      return formifyInlineFragmentDocument({
        inlineFragmentNode,
        type,
        path,
        showInSidebar
      });
    }
    return {
      ...inlineFragmentNode,
      selectionSet: {
        kind: "SelectionSet",
        selections: inlineFragmentNode.selectionSet.selections.map((selectionNode) => {
          switch (selectionNode.kind) {
            case "Field":
              return formifyFieldNode({
                fieldNode: selectionNode,
                parentType: type,
                path
              });
            default:
              throw new FormifyError("UNEXPECTED", `selection ${selectionNode.kind}`);
          }
        })
      }
    };
  };
  const formifiedQuery = {
    kind: "Document",
    definitions: optimizedQuery.definitions.map((definition) => {
      typeInfo.enter(definition);
      ensureOperationDefinition(definition);
      const parentType = typeInfo.getType();
      return {
        ...definition,
        selectionSet: {
          kind: "SelectionSet",
          selections: definition.selectionSet.selections.map((selectionNode) => {
            switch (selectionNode.kind) {
              case "Field":
                const field = getObjectField(parentType, selectionNode);
                const path = buildPath({
                  fieldNode: selectionNode,
                  type: field.type
                });
                if (isFormifiableDocument(field.type)) {
                  return formifyFieldNodeDocument({
                    fieldNode: selectionNode,
                    type: field.type,
                    path,
                    showInSidebar: true
                  });
                } else if (isConnectionField(field.type)) {
                  return formifyConnection({
                    parentType: field.type,
                    selectionNode,
                    path
                  });
                }
                if (selectionNode.name.value === COLLECTION_FIELD_NAME || selectionNode.name.value === COLLECTIONS_FIELD_NAME) {
                  const path2 = buildPath({
                    fieldNode: selectionNode,
                    type: field.type
                  });
                  return {
                    ...selectionNode,
                    selectionSet: {
                      kind: "SelectionSet",
                      selections: selectionNode.selectionSet.selections.map((subSelectionNode) => {
                        switch (subSelectionNode.kind) {
                          case "Field":
                            if (subSelectionNode.name.value === COLLECTIONS_DOCUMENTS_NAME) {
                              const subField = getObjectField(field.type, subSelectionNode);
                              return formifyConnection({
                                parentType: subField.type,
                                selectionNode: subSelectionNode,
                                path: buildPath({
                                  fieldNode: subSelectionNode,
                                  type: subField.type,
                                  path: path2
                                })
                              });
                            }
                            return subSelectionNode;
                          default:
                            throw new FormifyError("NOOP");
                        }
                      })
                    }
                  };
                }
                throw new FormifyError("NOOP");
              default:
                throw new FormifyError("UNEXPECTED");
            }
          })
        }
      };
    })
  };
  return { formifiedQuery, blueprints };
};
class FormifyError extends Error {
  constructor(code, details) {
    let message;
    switch (code) {
      case "NOOP":
        message = NOOP;
        break;
      case "UNEXPECTED":
        message = UNEXPECTED;
        break;
      default:
        message = "";
        break;
    }
    super(`${message} ${details || ""}`);
    this.name = "FormifyError";
  }
}
const defaultState = {
  status: "idle",
  schema: void 0,
  query: null,
  queryString: null,
  data: {},
  changeSets: [],
  count: 0,
  blueprints: [],
  formNodes: [],
  documentForms: []
};
function reducer(state, action) {
  var _a, _b, _c, _d;
  switch (action.type) {
    case "start":
      return {
        ...state,
        ...defaultState,
        query: action.value.query ? G.parse(action.value.query) : null,
        queryString: action.value.query,
        status: "initialized"
      };
    case "addDocumentBlueprints":
      return {
        ...state,
        status: "formified",
        blueprints: action.value.blueprints,
        query: action.value.formifiedQuery
      };
    case "addOrReplaceDocumentFormNode": {
      const existingDocumentForms = state.documentForms.filter((documentForm) => {
        var _a2, _b2;
        return documentForm.id !== ((_b2 = (_a2 = action.value) == null ? void 0 : _a2.documentForm) == null ? void 0 : _b2.id);
      });
      const existingDocumentFormNodes = state.formNodes.filter((formNode) => {
        return formNodeId(formNode) !== formNodeId(action.value.formNode);
      });
      const newDocumentForms = [];
      if ((_a = action.value) == null ? void 0 : _a.documentForm) {
        newDocumentForms.push((_b = action.value) == null ? void 0 : _b.documentForm);
      }
      return {
        ...state,
        formNodes: [...existingDocumentFormNodes, action.value.formNode],
        documentForms: [...existingDocumentForms, ...newDocumentForms]
      };
    }
    case "onFieldChange": {
      const event = action.value.event;
      const changeSets = [];
      const formNodesToReplace = [];
      const formNodesToRemove = [];
      const newFormNodes = [];
      const form = state.documentForms.find((documentForm) => documentForm.id === event.formId);
      getFormNodesFromEvent(state, event).forEach((formNode) => {
        const blueprint = getFormNodeBlueprint(formNode, state);
        if (blueprint.hasValuesField) {
          changeSets.push({
            path: [formNodePath(formNode), "values"].join("."),
            ...buildChangeSet(event, formNode),
            value: form.values,
            mutationType: {
              type: "global"
            }
          });
        }
        if (blueprint.hasDataJSONField) {
          changeSets.push({
            path: [formNodePath(formNode), "dataJSON"].join("."),
            ...buildChangeSet(event, formNode),
            value: form.values,
            mutationType: {
              type: "global"
            }
          });
        }
        if (event.mutationType.type === "change") {
          if (!action.value.form) {
            getBlueprintFieldsForEvent(blueprint, event).forEach((fieldBlueprint) => {
              const { pathToChange } = getFormNodesForField(fieldBlueprint, formNode, event, state);
              changeSets.push({
                path: pathToChange,
                ...buildChangeSet(event, formNode)
              });
            });
          }
        } else if (event.mutationType.type === "referenceChange") {
          getBlueprintFieldsForEvent(blueprint, event).forEach((fieldBlueprint) => {
            const {
              pathToChange,
              formNodes: subFormNodes,
              eventLocation
            } = getFormNodesForField(fieldBlueprint, formNode, event, state);
            if (action.value.form && state.blueprints.find((blueprint2) => blueprint2.id === fieldBlueprint.id)) {
              const newFormNode = {
                documentBlueprintId: fieldBlueprint.id,
                documentFormId: action.value.form.id,
                location: eventLocation
              };
              newFormNodes.push(newFormNode);
              changeSets.push({
                path: pathToChange,
                ...buildChangeSet(event, newFormNode)
              });
            }
            subFormNodes.forEach((subFormNode) => {
              if (matchLocation(eventLocation, subFormNode)) {
                if (!action.value.form) {
                  changeSets.push({
                    path: pathToChange,
                    ...buildChangeSet(event, subFormNode),
                    value: null
                  });
                }
                formNodesToReplace.push(subFormNode);
              }
            });
          });
        } else {
          getBlueprintFieldsForEvent(blueprint, event).forEach((fieldBlueprint) => {
            const { pathToChange, formNodes, existing, eventLocation } = getFormNodesForField(fieldBlueprint, formNode, event, state);
            if (event.mutationType.type === "insert") {
              formNodes.forEach((subFormNode) => {
                if (matchLocation(eventLocation, subFormNode)) {
                  newFormNodes.push({
                    ...subFormNode,
                    location: bumpLocation(subFormNode.location)
                  });
                  formNodesToReplace.push(subFormNode);
                }
              });
              changeSets.push({
                path: pathToChange,
                ...buildChangeSet(event, formNode)
              });
            }
            if (event.mutationType.type === "remove") {
              const { at } = event.mutationType;
              formNodes.forEach((subFormNode) => {
                if (matchLocation(eventLocation, subFormNode)) {
                  if (matchesAt(subFormNode.location, at)) {
                    formNodesToRemove.push(subFormNode);
                  } else {
                    newFormNodes.push({
                      ...subFormNode,
                      location: maybeLowerLocation(subFormNode.location, at)
                    });
                    formNodesToReplace.push(subFormNode);
                  }
                }
              });
              const next = existing.filter((_, index) => index !== at);
              changeSets.push({
                path: pathToChange,
                ...buildChangeSet(event, formNode),
                value: next
              });
            }
            if (event.mutationType.type === "move") {
              const next = [];
              const { from, to } = event.mutationType;
              const newOrderObject = getMoveMapping(existing, from, to);
              formNodes.forEach((subFormNode) => {
                if (matchLocation(eventLocation, subFormNode)) {
                  newFormNodes.push({
                    ...subFormNode,
                    location: swapLocation(subFormNode.location, newOrderObject)
                  });
                  formNodesToReplace.push(subFormNode);
                }
              });
              Object.values(newOrderObject).forEach((orderIndex, index) => {
                next[orderIndex] = existing[index];
              });
              changeSets.push({
                path: pathToChange,
                ...buildChangeSet(event, formNode),
                value: next
              });
            }
          });
        }
      });
      const existingDocumentForms = state.documentForms.filter((documentForm) => {
        var _a2;
        return documentForm.id !== ((_a2 = action.value.form) == null ? void 0 : _a2.id);
      });
      const newDocumentForms = [];
      if ((_c = action.value) == null ? void 0 : _c.form) {
        newDocumentForms.push((_d = action.value) == null ? void 0 : _d.form);
      }
      return {
        ...state,
        changeSets,
        formNodes: [
          ...state.formNodes.filter((formNode) => formNodeNotIn(formNode, formNodesToReplace)).filter((formNode) => formNodeNotIn(formNode, formNodesToRemove)),
          ...newFormNodes
        ],
        documentForms: [...existingDocumentForms, ...newDocumentForms]
      };
    }
    case "formOnReset": {
      const { event } = action.value;
      const changeSets = [];
      const form = state.documentForms.find((documentForm) => documentForm.id === event.formId);
      state.formNodes.filter((fn) => fn.documentFormId === (form == null ? void 0 : form.id)).forEach((formNode) => {
        const blueprint = getFormNodeBlueprint(formNode, state);
        if (blueprint.hasValuesField) {
          changeSets.push({
            path: [formNodePath(formNode), "_values"].join("."),
            ...buildChangeSet(event, formNode)
          });
        }
        changeSets.push({
          path: [formNodePath(formNode)].join("."),
          ...buildChangeSet(event, formNode)
        });
      });
      return { ...state, changeSets };
    }
    case "ready":
      return { ...state, status: "ready" };
    case "done":
      return { ...state, status: "done" };
    case "setData":
      return { ...state, data: action.value };
    case "setIn": {
      let newData;
      if (action.value.displaceIndex) {
        const existing = getIn(state.data, action.value.path) || [];
        newData = setIn(state.data, action.value.path, [
          action.value.value,
          ...existing
        ]);
      } else {
        newData = setIn(state.data, action.value.path, action.value.value);
      }
      const changeSets = state.changeSets.filter((cs) => cs.path !== action.value.path);
      return {
        ...state,
        data: newData,
        changeSets
      };
    }
    default:
      return state;
  }
}
const buildChangeSet = (event, formNode) => {
  var _a, _b, _c;
  return {
    fieldDefinition: (_b = (_a = event.field) == null ? void 0 : _a.data) == null ? void 0 : _b.tinaField,
    name: (_c = event.field) == null ? void 0 : _c.name,
    formId: event.formId,
    mutationType: event.mutationType,
    value: event.value,
    formNode
  };
};
const useFormify = ({
  query,
  cms,
  variables,
  onSubmit,
  formify: formifyFunc,
  eventList
}) => {
  const formIds = React.useRef([]);
  const [state, dispatch] = React.useReducer(reducer, {
    status: "idle",
    schema: void 0,
    query: query ? G.parse(query) : null,
    queryString: query,
    data: {},
    changeSets: [],
    count: 0,
    blueprints: [],
    formNodes: [],
    documentForms: []
  });
  React.useEffect(() => {
    if (query) {
      dispatch({ type: "start", value: { query } });
      formIds.current.forEach((formId) => {
        const form = cms.forms.find(formId);
        if (form) {
          cms.plugins.remove(form);
        }
      });
    }
  }, [query, JSON.stringify(variables)]);
  React.useEffect(() => {
    if (state.status === "initialized") {
      cms.api.tina.request(query, { variables }).then((res) => {
        delete res.paths;
        dispatch({ type: "setData", value: res });
      });
    }
  }, [state.status]);
  React.useEffect(() => {
    const run = async () => {
      const schema = await cms.api.tina.getSchema();
      const result = await formify({
        schema,
        query,
        getOptimizedQuery: cms.api.tina.getOptimizedQuery
      });
      dispatch({
        type: "addDocumentBlueprints",
        value: result
      });
    };
    if (state.status === "initialized") {
      run();
    }
  }, [state.status]);
  React.useEffect(() => {
    const run = async () => {
      const result = await cms.api.tina.request(G.print(state.query), {
        variables
      });
      state.blueprints.map((blueprint) => {
        const responseAtBlueprint = getValueForBlueprint(result, getBlueprintAliasPath(blueprint));
        const location = [];
        const findFormNodes = (res, location2) => {
          if (Array.isArray(res)) {
            res.forEach((item, index) => {
              if (Array.isArray(item)) {
                findFormNodes(item, [...location2, index]);
              } else {
                if (item) {
                  const form = buildForm(item, cms, formifyFunc, blueprint.showInSidebar, onSubmit);
                  const formNode = buildFormNode(blueprint, form, [
                    ...location2,
                    index
                  ]);
                  dispatch({
                    type: "addOrReplaceDocumentFormNode",
                    value: {
                      formNode,
                      documentForm: form
                    }
                  });
                }
              }
            });
          } else {
            if (res) {
              const form = buildForm(res, cms, formifyFunc, blueprint.showInSidebar, onSubmit);
              const formNode = buildFormNode(blueprint, form, location2);
              dispatch({
                type: "addOrReplaceDocumentFormNode",
                value: {
                  formNode,
                  documentForm: form
                }
              });
            }
          }
        };
        findFormNodes(responseAtBlueprint, location);
      });
      dispatch({ type: "ready" });
    };
    if (state.status === "formified") {
      run();
    }
  }, [state.status]);
  React.useEffect(() => {
    if (state.status === "ready") {
      cms.events.subscribe(`forms:reset`, (event) => {
        if (eventList) {
          eventList.push(printEvent(event));
        }
        dispatch({ type: "formOnReset", value: { event } });
      });
      cms.events.subscribe(`forms:fields:onChange`, async (event) => {
        if (eventList) {
          eventList.push(printEvent(event));
        }
        if (event.field.data.tinaField.type === "reference") {
          let form;
          if (event.value && typeof event.value === "string") {
            const existingForm = cms.forms.find(event.value);
            if (existingForm) {
              form = existingForm;
            } else {
              const formInfo = await cms.api.tina.request(`#graphql
                    query Node($id: String!) {
                      node(id: $id) {
                        ...on Document {
                          _values
                          _internalSys: _sys {
                            path
                            relativePath
                            collection {
                              name
                            }
                          }
                        }
                      }
                    }
                    `, { variables: { id: event.value } });
              form = buildForm(formInfo.node, cms, formifyFunc, false, onSubmit);
            }
          }
          dispatch({
            type: "onFieldChange",
            value: {
              event: {
                ...event,
                mutationType: { type: "referenceChange" }
              },
              form
            }
          });
        } else {
          dispatch({ type: "onFieldChange", value: { event } });
        }
      });
      dispatch({ type: "done" });
    }
  }, [state.status]);
  React.useEffect(() => {
    state.changeSets.forEach((changeSet) => {
      if (changeSet.mutationType.type === "reset") {
        const form = cms.forms.find(changeSet.formId);
        resolveSubFields({
          formNode: changeSet.formNode,
          form,
          loc: []
        }).then((res) => {
          dispatch({
            type: "setIn",
            value: {
              value: res,
              path: changeSet.path
            }
          });
        });
        return;
      } else if (changeSet.mutationType.type === "insert") {
        if (changeSet.fieldDefinition.type === "object") {
          const fieldName = changeSet.fieldDefinition.list ? `${changeSet.name}.[]` : changeSet.name;
          const { fields, __typename } = getSubFields(changeSet);
          resolveSubFields({
            formNode: changeSet.formNode,
            prefix: replaceRealNum(fieldName),
            loc: [...stripIndices(changeSet.path), 0],
            form: {
              fields,
              values: changeSet.value[0]
            }
          }).then((res) => {
            const extra = {};
            if (__typename) {
              extra["__typename"] = __typename;
            }
            dispatch({
              type: "setIn",
              value: {
                displaceIndex: true,
                ...changeSet,
                value: {
                  ...res,
                  ...extra
                }
              }
            });
          });
        } else {
          dispatch({
            type: "setIn",
            value: {
              displaceIndex: true,
              ...changeSet,
              value: changeSet.value[0]
            }
          });
        }
      } else {
        if (changeSet.mutationType.type === "referenceChange") {
          const { formNode } = changeSet;
          const blueprint = getFormNodeBlueprint(formNode, state);
          if (!changeSet.value) {
            dispatch({
              type: "setIn",
              value: {
                ...changeSet,
                value: null
              }
            });
          } else {
            cms.api.tina.request(`
              query Node($id: String!) {
                node(id: $id) {
                  ${G.print(blueprint.selection)}
                }
              }
            `, { variables: { id: changeSet.value } }).then(async (res) => {
              const form = state.documentForms.find((documentForm) => documentForm.id === formNode.documentFormId);
              const data = await resolveSubFields({
                formNode,
                form,
                loc: formNode.location
              });
              dispatch({
                type: "setIn",
                value: {
                  ...changeSet,
                  value: {
                    ...res.node,
                    ...data
                  }
                }
              });
            }).catch((e) => {
              cms.alerts.error(`Unexpected error fetching reference.`);
              console.log(e);
            });
          }
        } else {
          dispatch({ type: "setIn", value: changeSet });
        }
      }
    });
  }, [JSON.stringify(state.changeSets)]);
  React.useEffect(() => {
    formIds.current = state.documentForms.map((df) => df.id);
  }, [state.documentForms.length]);
  React.useEffect(() => {
    return () => {
      formIds.current.forEach((formId) => {
        const form = cms.forms.find(formId);
        if (form) {
          cms.plugins.remove(form);
        }
      });
    };
  }, []);
  const resolveSubFields = React.useCallback(async (args) => {
    const { form, formNode, prefix, loc } = args;
    const data = {};
    await sequential(form.fields, async (field) => {
      const value = form.values[field.name];
      const blueprint = getFormNodeBlueprint(formNode, state);
      const { matchName, fieldName } = getMatchName({
        field,
        prefix,
        blueprint
      });
      const fieldBlueprints = blueprint.fields.filter((fieldBlueprint) => {
        return matchName === getBlueprintNamePath(fieldBlueprint);
      }).filter((fbp) => filterFieldBlueprintsByParentTypename(fbp, field.parentTypename));
      switch (field.type) {
        case "object":
          if (field.templates) {
            if (field.list) {
              await sequential(fieldBlueprints, async (fieldBlueprint) => {
                const keyName = getFieldNameOrAlias(fieldBlueprint);
                if (!value) {
                  data[keyName] = null;
                  return true;
                }
                if (!Array.isArray(value)) {
                  throw new Error(`Expected value for object list field to be an array`);
                }
                data[keyName] = await sequential(value, async (item, index) => {
                  const template = field.templates[item._template];
                  return {
                    ...await resolveSubFields({
                      formNode,
                      form: { fields: template.fields, values: item },
                      prefix: prefix ? [prefix, fieldName].join(".") : fieldName,
                      loc: [...loc, index]
                    }),
                    __typename: field.typeMap[item._template]
                  };
                });
              });
            } else {
              throw new Error("blocks without list true is not yet supported");
            }
          } else {
            if (field.list) {
              await sequential(fieldBlueprints, async (fieldBlueprint) => {
                const keyName = getFieldNameOrAlias(fieldBlueprint);
                if (!value) {
                  data[keyName] = null;
                  return true;
                }
                if (!Array.isArray(value)) {
                  throw new Error(`Expected value for object list field to be an array`);
                }
                data[keyName] = await sequential(value, async (item, index) => {
                  return resolveSubFields({
                    formNode,
                    form: { fields: field.fields, values: item },
                    prefix: [prefix, fieldName].join("."),
                    loc: [...loc, index]
                  });
                });
                return true;
              });
            } else {
              await sequential(fieldBlueprints, async (fieldBlueprint) => {
                const keyName = getFieldNameOrAlias(fieldBlueprint);
                if (!value) {
                  data[keyName] = null;
                  return true;
                }
                data[keyName] = await resolveSubFields({
                  formNode,
                  form: { fields: field.fields, values: value },
                  prefix: [prefix, fieldName].join("."),
                  loc
                });
                return true;
              });
            }
          }
          break;
        case "reference":
          let form2;
          if (typeof value === "string") {
            const existingForm = cms.forms.find(value);
            if (existingForm) {
              form2 = existingForm;
            } else {
              const formInfo = await cms.api.tina.request(`#graphql
                      query Node($id: String!) {
                        node(id: $id) {
                          ...on Document {
                            _values
                            _internalSys: _sys {
                              path
                              relativePath
                              collection {
                                name
                              }
                            }
                          }
                        }
                      }
                    `, { variables: { id: value } });
              form2 = buildForm(formInfo.node, cms, formifyFunc, false, onSubmit);
            }
          }
          await sequential(fieldBlueprints, async (fieldBlueprint) => {
            const keyName = getFieldNameOrAlias(fieldBlueprint);
            if (!value) {
              data[keyName] = null;
              return true;
            }
            const documentBlueprint = state.blueprints.find((dp) => getBlueprintNamePath(dp) === matchName);
            const location = [...formNode.location];
            if (loc) {
              loc.forEach((item) => location.push(item));
            }
            const subDocumentFormNode = buildFormNode(documentBlueprint, form2, location);
            dispatch({
              type: "addOrReplaceDocumentFormNode",
              value: {
                formNode: subDocumentFormNode,
                documentForm: form2
              }
            });
            const res = await cms.api.tina.request(`
                    query Node($id: String!) {
                      node(id: $id) {
                        ${G.print(documentBlueprint.selection)}
                      }
                    }
                  `, { variables: { id: value } });
            data[keyName] = {
              ...res.node,
              ...await resolveSubFields({
                formNode: subDocumentFormNode,
                form: form2,
                loc: location
              })
            };
          });
          break;
        default:
          fieldBlueprints.forEach((fieldBlueprint) => {
            const keyName = getFieldNameOrAlias(fieldBlueprint);
            if (!value) {
              data[keyName] = null;
            } else {
              data[keyName] = value;
            }
          });
          break;
      }
      return true;
    });
    return data;
  }, [cms, JSON.stringify(state), dispatch]);
  return {
    ...state,
    queryString: G.print(state.query)
  };
};
const buildFormNode = (documentBlueprint, form, location) => {
  return {
    documentBlueprintId: documentBlueprint.id,
    documentFormId: form.id,
    location
  };
};
const captureBranchName = /^refs\/heads\/(.*)/;
const parseRefForBranchName = (ref) => {
  const matches = ref.match(captureBranchName);
  return matches[1];
};
class Client {
  constructor({ tokenStorage = "MEMORY", ...options }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P;
    this.events = new EventBus();
    this.addPendingContent = async (props) => {
      const mutation = `#graphql
mutation addPendingDocumentMutation(
  $relativePath: String!
  $collection: String!
  $template: String
) {
  addPendingDocument(
    relativePath: $relativePath
    template: $template
    collection: $collection
  ) {
    ... on Document {
      _sys {
        relativePath
        path
        breadcrumbs
        collection {
          slug
        }
      }
    }
  }
}`;
      const result = await this.request(mutation, {
        variables: props
      });
      return result;
    };
    this.getSchema = async () => {
      if (!this.gqlSchema) {
        const data = await this.request(getIntrospectionQuery(), {
          variables: {}
        });
        this.gqlSchema = buildClientSchema(data);
      }
      return this.gqlSchema;
    };
    this.getOptimizedQuery = async (documentNode) => {
      const data = await this.request(`query GetOptimizedQuery($queryString: String!) {
        getOptimizedQuery(queryString: $queryString)
      }`, {
        variables: { queryString: print(documentNode) }
      });
      return parse(data.getOptimizedQuery);
    };
    this.onLogin = (_d = (_c = (_b = (_a = options.schema) == null ? void 0 : _a.config) == null ? void 0 : _b.admin) == null ? void 0 : _c.auth) == null ? void 0 : _d.onLogin;
    this.onLogout = (_h = (_g = (_f = (_e = options.schema) == null ? void 0 : _e.config) == null ? void 0 : _f.admin) == null ? void 0 : _g.auth) == null ? void 0 : _h.onLogout;
    if ((_l = (_k = (_j = (_i = options.schema) == null ? void 0 : _i.config) == null ? void 0 : _j.admin) == null ? void 0 : _k.auth) == null ? void 0 : _l.logout) {
      this.onLogout = (_p = (_o = (_n = (_m = options.schema) == null ? void 0 : _m.config) == null ? void 0 : _n.admin) == null ? void 0 : _o.auth) == null ? void 0 : _p.logout;
    }
    if ((_t = (_s = (_r = (_q = options.schema) == null ? void 0 : _q.config) == null ? void 0 : _r.admin) == null ? void 0 : _s.auth) == null ? void 0 : _t.getUser) {
      this.getUser = (_x = (_w = (_v = (_u = options.schema) == null ? void 0 : _u.config) == null ? void 0 : _v.admin) == null ? void 0 : _w.auth) == null ? void 0 : _x.getUser;
    }
    if ((_B = (_A = (_z = (_y = options.schema) == null ? void 0 : _y.config) == null ? void 0 : _z.admin) == null ? void 0 : _A.auth) == null ? void 0 : _B.authenticate) {
      this.authenticate = (_F = (_E = (_D = (_C = options.schema) == null ? void 0 : _C.config) == null ? void 0 : _D.admin) == null ? void 0 : _E.auth) == null ? void 0 : _F.authenticate;
    }
    if (options.schema) {
      const enrichedSchema = new TinaSchema({
        version: { fullVersion: "", major: "", minor: "", patch: "" },
        meta: { flags: [] },
        ...addNamespaceToSchema({ ...options.schema }, [])
      });
      this.schema = enrichedSchema;
    }
    this.options = options;
    if ((_H = (_G = options.schema) == null ? void 0 : _G.config) == null ? void 0 : _H.contentApiUrlOverride) {
      this.options.customContentApiUrl = options.schema.config.contentApiUrlOverride;
    }
    this.setBranch(options.branch);
    this.events.subscribe("branch:change", ({ branchName }) => {
      this.setBranch(branchName);
    });
    this.clientId = options.clientId;
    switch (tokenStorage) {
      case "LOCAL_STORAGE":
        this.getToken = async function() {
          const tokens = localStorage.getItem(AUTH_TOKEN_KEY) || null;
          if (tokens) {
            return await this.getRefreshedToken(tokens);
          } else {
            return {
              access_token: null,
              id_token: null,
              refresh_token: null
            };
          }
        };
        this.setToken = function(token) {
          localStorage.setItem(AUTH_TOKEN_KEY, JSON.stringify(token, null, 2));
        };
        break;
      case "MEMORY":
        this.getToken = async () => {
          if (this.token) {
            return await this.getRefreshedToken(this.token);
          } else {
            return {
              access_token: null,
              id_token: null,
              refresh_token: null
            };
          }
        };
        this.setToken = (token) => {
          this.token = JSON.stringify(token, null, 2);
        };
        break;
      case "CUSTOM":
        if (!options.getTokenFn) {
          throw new Error("When CUSTOM token storage is selected, a getTokenFn must be provided");
        }
        this.getToken = options.getTokenFn;
        break;
    }
    if ((_L = (_K = (_J = (_I = options.schema) == null ? void 0 : _I.config) == null ? void 0 : _J.admin) == null ? void 0 : _K.auth) == null ? void 0 : _L.getToken) {
      this.getToken = (_P = (_O = (_N = (_M = options.schema) == null ? void 0 : _M.config) == null ? void 0 : _N.admin) == null ? void 0 : _O.auth) == null ? void 0 : _P.getToken;
    }
  }
  get isLocalMode() {
    return false;
  }
  setBranch(branchName) {
    var _a, _b, _c, _d;
    const encodedBranch = encodeURIComponent(branchName);
    this.branch = encodedBranch;
    this.assetsApiUrl = ((_a = this.options.tinaioConfig) == null ? void 0 : _a.assetsApiUrlOverride) || "https://assets.tinajs.io";
    this.frontendUrl = ((_b = this.options.tinaioConfig) == null ? void 0 : _b.frontendUrlOverride) || "https://app.tina.io";
    this.identityApiUrl = ((_c = this.options.tinaioConfig) == null ? void 0 : _c.identityApiUrlOverride) || "https://identity.tinajs.io";
    this.contentApiBase = ((_d = this.options.tinaioConfig) == null ? void 0 : _d.contentApiUrlOverride) || `https://content.tinajs.io`;
    this.contentApiUrl = this.options.customContentApiUrl || `${this.contentApiBase}/content/${this.options.clientId}/github/${encodedBranch}`;
  }
  async requestWithForm(query, {
    variables,
    useUnstableFormify
  }) {
    const schema = await this.getSchema();
    let formifiedQuery;
    if (useUnstableFormify) {
      const res = await formify({
        schema,
        query: print(query(gql$1)),
        getOptimizedQuery: this.getOptimizedQuery
      });
      formifiedQuery = res.formifiedQuery;
    } else {
      formifiedQuery = formify$1(query(gql$1), schema);
    }
    return this.request(print(formifiedQuery), { variables });
  }
  async request(query, { variables }) {
    const res = await fetch(this.contentApiUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + (await this.getToken()).id_token
      },
      body: JSON.stringify({
        query: typeof query === "function" ? print(query(gql$1)) : query,
        variables
      })
    });
    if (res.status !== 200) {
      let errorMessage = `Unable to complete request, ${res.statusText}`;
      const resBody = await res.json();
      if (resBody.message) {
        errorMessage = `${errorMessage}, Response: ${resBody.message}`;
      }
      throw new Error(errorMessage);
    }
    const json = await res.json();
    if (json.errors) {
      throw new Error(`Unable to fetch, errors: 
	${json.errors.map((error) => error.message).join("\n")}`);
    }
    return json.data;
  }
  async syncTinaMedia() {
    const res = await this.fetchWithToken(`${this.contentApiBase}/assets/${this.clientId}/sync/${this.branch}`, { method: "POST" });
    const jsonRes = await res.json();
    return jsonRes;
  }
  async checkSyncStatus({
    assetsSyncing
  }) {
    const res = await this.fetchWithToken(`${this.assetsApiUrl}/v1/${this.clientId}/syncStatus`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ assetsSyncing })
    });
    const jsonRes = await res.json();
    return jsonRes;
  }
  async fetchEvents(limit, cursor) {
    if (this.isLocalMode) {
      return {
        events: []
      };
    } else {
      return (await this.fetchWithToken(`${this.contentApiBase}/events/${this.clientId}/${this.branch}?limit=${limit || 1}${cursor ? `&cursor=${cursor}` : ""}`, { method: "GET" })).json();
    }
  }
  parseJwt(token) {
    const base64Url = token.split(".")[1];
    const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
    const jsonPayload = decodeURIComponent(atob(base64).split("").map(function(c) {
      return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(""));
    return JSON.parse(jsonPayload);
  }
  async getRefreshedToken(tokens) {
    const { access_token, id_token, refresh_token } = JSON.parse(tokens);
    const { exp, iss, client_id } = this.parseJwt(access_token);
    if (Date.now() / 1e3 >= exp - 120) {
      const refreshResponse = await fetch(iss, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-amz-json-1.1",
          "x-amz-target": "AWSCognitoIdentityProviderService.InitiateAuth"
        },
        body: JSON.stringify({
          ClientId: client_id,
          AuthFlow: "REFRESH_TOKEN_AUTH",
          AuthParameters: {
            REFRESH_TOKEN: refresh_token,
            DEVICE_KEY: null
          }
        })
      });
      if (refreshResponse.status !== 200) {
        throw new Error("Unable to refresh auth tokens");
      }
      const responseJson = await refreshResponse.json();
      const newToken = {
        access_token: responseJson.AuthenticationResult.AccessToken,
        id_token: responseJson.AuthenticationResult.IdToken,
        refresh_token
      };
      this.setToken(newToken);
      return Promise.resolve(newToken);
    }
    return Promise.resolve({ access_token, id_token, refresh_token });
  }
  async isAuthorized() {
    return this.isAuthenticated();
  }
  async isAuthenticated() {
    return !!await this.getUser();
  }
  async logout() {
    this.setToken(null);
  }
  async authenticate() {
    const token = await authenticate(this.clientId, this.frontendUrl);
    this.setToken(token);
    return token;
  }
  async fetchWithToken(input, init) {
    const headers = (init == null ? void 0 : init.headers) || {};
    return await fetch(input, {
      ...init,
      headers: new Headers({
        Authorization: "Bearer " + (await this.getToken()).id_token,
        ...headers
      })
    });
  }
  async getUser() {
    if (!this.clientId) {
      return null;
    }
    const url = `${this.identityApiUrl}/v2/apps/${this.clientId}/currentUser`;
    try {
      const res = await this.fetchWithToken(url, {
        method: "GET"
      });
      const val = await res.json();
      if (!res.status.toString().startsWith("2")) {
        console.error(val.error);
        return null;
      }
      return val;
    } catch (e) {
      console.error(e);
      return null;
    }
  }
  async getBillingState() {
    if (!this.clientId) {
      return null;
    }
    const url = `${this.identityApiUrl}/v2/apps/${this.clientId}/billing/state`;
    try {
      const res = await this.fetchWithToken(url, {
        method: "GET"
      });
      const val = await res.json();
      if (!res.status.toString().startsWith("2")) {
        console.error(val.error);
        return null;
      }
      return {
        clientId: val.clientId || this.clientId,
        delinquencyDate: val.delinquencyDate,
        billingState: val.billingState
      };
    } catch (e) {
      console.error(e);
      return null;
    }
  }
  async listBranches() {
    const url = `${this.contentApiBase}/github/${this.clientId}/list_branches`;
    const res = await this.fetchWithToken(url, {
      method: "GET"
    });
    return res.json();
  }
  async createBranch({ baseBranch, branchName }) {
    const url = `${this.contentApiBase}/github/${this.clientId}/create_branch`;
    try {
      const res = await this.fetchWithToken(url, {
        method: "POST",
        body: JSON.stringify({
          baseBranch,
          branchName
        }),
        headers: {
          "Content-Type": "application/json"
        }
      });
      return await res.json().then((r) => parseRefForBranchName(r.data.ref));
    } catch (error) {
      console.error("There was an error creating a new branch.", error);
      return null;
    }
  }
}
const DEFAULT_LOCAL_TINA_GQL_SERVER_URL = "http://localhost:4001/graphql";
const LOCAL_CLIENT_KEY = "tina.local.isLogedIn";
class LocalClient extends Client {
  constructor(props) {
    const clientProps = {
      ...props,
      clientId: "",
      branch: "",
      customContentApiUrl: props && props.customContentApiUrl ? props.customContentApiUrl : DEFAULT_LOCAL_TINA_GQL_SERVER_URL
    };
    super(clientProps);
  }
  get isLocalMode() {
    return true;
  }
  async logout() {
    localStorage.removeItem(LOCAL_CLIENT_KEY);
  }
  async authenticate() {
    localStorage.setItem(LOCAL_CLIENT_KEY, "true");
    return { access_token: "LOCAL", id_token: "LOCAL", refresh_token: "LOCAL" };
  }
  async getUser() {
    return localStorage.getItem(LOCAL_CLIENT_KEY) === "true";
  }
}
function ModalBuilder(modalProps) {
  return /* @__PURE__ */ React.createElement(Modal, null, /* @__PURE__ */ React.createElement(ModalPopup, null, /* @__PURE__ */ React.createElement(ModalHeader, null, modalProps.title), /* @__PURE__ */ React.createElement(ModalBody, {
    padded: true
  }, /* @__PURE__ */ React.createElement("p", null, modalProps.message), modalProps.error && /* @__PURE__ */ React.createElement(ErrorLabel, null, modalProps.error)), /* @__PURE__ */ React.createElement(ModalActions, null, modalProps.actions.map((action) => /* @__PURE__ */ React.createElement(AsyncButton, {
    key: action.name,
    ...action
  })))));
}
const ErrorLabel = ({ style = {}, ...props }) => /* @__PURE__ */ React.createElement("p", {
  style: { ...style, color: "var(--tina-color-error)" },
  ...props
});
const AsyncButton = ({ name, primary, action }) => {
  const [submitting, setSubmitting] = useState(false);
  const onClick = useCallback(async () => {
    setSubmitting(true);
    try {
      await action();
      setSubmitting(false);
    } catch (e) {
      setSubmitting(false);
      throw e;
    }
  }, [action, setSubmitting]);
  return /* @__PURE__ */ React.createElement(Button, {
    variant: primary ? "primary" : "secondary",
    onClick,
    busy: submitting,
    disabled: submitting
  }, submitting && /* @__PURE__ */ React.createElement(LoadingDots, null), !submitting && name);
};
const TINA_AUTH_CONFIG = "tina_auth_config";
const useTinaAuthRedirect = () => {
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const config = {
      code: urlParams.get("code") || "",
      scope: urlParams.get("scope") || "email",
      state: urlParams.get("state")
    };
    if (!config.code) {
      return;
    }
    localStorage[TINA_AUTH_CONFIG] = JSON.stringify(config);
  }, []);
};
class TinaAdminApi {
  constructor(cms) {
    this.api = cms.api.tina;
    this.schema = cms.api.tina.schema;
  }
  async isAuthenticated() {
    return await this.api.isAuthenticated();
  }
  fetchCollections() {
    return this.schema.getCollections();
  }
  async renameDocument({ collection, relativePath, newRelativePath }) {
    await this.api.request(`#graphql
              mutation RenameDocument($collection: String!, $relativePath: String! $newRelativePath: String!) {
                updateDocument(collection: $collection, relativePath: $relativePath, params: {relativePath: $newRelativePath}){
    __typename
  }
              }
            `, { variables: { collection, relativePath, newRelativePath } });
  }
  async deleteDocument({
    collection,
    relativePath
  }) {
    await this.api.request(`#graphql
      mutation DeleteDocument($collection: String!, $relativePath: String!  ){
  deleteDocument(collection: $collection, relativePath: $relativePath){
    __typename
  }
}`, { variables: { collection, relativePath } });
  }
  async fetchCollection(collectionName, includeDocuments, after, sortKey, order, filterArgs) {
    let filter = null;
    const filterField = filterArgs == null ? void 0 : filterArgs.filterField;
    if (filterField) {
      filter = {
        [collectionName]: {
          [filterField]: {}
        }
      };
    }
    if (filterField && (filterArgs == null ? void 0 : filterArgs.startsWith)) {
      filter[collectionName][filterField] = {
        ...filter[collectionName][filterField] || {},
        startsWith: filterArgs.startsWith
      };
    }
    if (filterField && (filterArgs == null ? void 0 : filterArgs.before)) {
      filter[collectionName][filterField] = {
        ...filter[collectionName][filterField] || {},
        before: filterArgs.before
      };
    }
    if (filterField && (filterArgs == null ? void 0 : filterArgs.after)) {
      filter[collectionName][filterField] = {
        ...filter[collectionName][filterField] || {},
        after: filterArgs.after
      };
    }
    if (filterField && (filterArgs == null ? void 0 : filterArgs.booleanEquals) !== null && (filterArgs == null ? void 0 : filterArgs.booleanEquals) !== void 0) {
      filter[collectionName][filterField] = {
        ...filter[collectionName][filterField] || {},
        eq: filterArgs.booleanEquals
      };
    }
    if (includeDocuments === true) {
      const sort = sortKey || this.schema.getIsTitleFieldName(collectionName);
      const response = order === "asc" ? await this.api.request(`#graphql
      query($collection: String!, $includeDocuments: Boolean!, $sort: String,  $limit: Float, $after: String, $filter: DocumentFilter){
        collection(collection: $collection){
          name
          label
          format
          templates
          documents(sort: $sort, after: $after, first: $limit, filter: $filter) @include(if: $includeDocuments) {
            totalCount
            pageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            edges {
              node {
                ... on Document {
                  _sys {
                    title
                    template
                    breadcrumbs
                    path
                    basename
                    relativePath
                    filename
                    extension
                  }
                }
              }
            }
          }
        }
      }`, {
        variables: {
          collection: collectionName,
          includeDocuments,
          sort,
          limit: 50,
          after,
          filter
        }
      }) : await this.api.request(`#graphql
      query($collection: String!, $includeDocuments: Boolean!, $sort: String,  $limit: Float, $after: String, $filter: DocumentFilter){
        collection(collection: $collection){
          name
          label
          format
          templates
          documents(sort: $sort, before: $after, last: $limit, filter: $filter) @include(if: $includeDocuments) {
            totalCount
            pageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            edges {
              node {
                ... on Document {
                  _sys {
                    title
                    template
                    breadcrumbs
                    path
                    basename
                    relativePath
                    filename
                    extension
                  }
                }
              }
            }
          }
        }
      }`, {
        variables: {
          collection: collectionName,
          includeDocuments,
          sort,
          limit: 50,
          after,
          filter
        }
      });
      return response.collection;
    } else {
      try {
        const collection = this.schema.getCollection(collectionName);
        return collection;
      } catch (e) {
        console.error(`[TinaAdminAPI] Unable to fetchCollection(): ${e.message}`);
        return void 0;
      }
    }
  }
  async fetchDocument(collectionName, relativePath) {
    const response = await this.api.request(`#graphql
      query($collection: String!, $relativePath: String!) {
        document(collection:$collection, relativePath:$relativePath) {
          ... on Document {
            _values
          }
        }
      }`, { variables: { collection: collectionName, relativePath } });
    return response;
  }
  async createDocument(collectionName, relativePath, params) {
    const response = await this.api.request(`#graphql
      mutation($collection: String!, $relativePath: String!, $params: DocumentMutation!) {
        createDocument(
          collection: $collection,
          relativePath: $relativePath,
          params: $params
        ){__typename}
      }`, {
      variables: {
        collection: collectionName,
        relativePath,
        params
      }
    });
    return response;
  }
  async updateDocument(collectionName, relativePath, params) {
    const response = await this.api.request(`#graphql
      mutation($collection: String!, $relativePath: String!, $params: DocumentUpdateMutation!) {
        updateDocument(
          collection: $collection,
          relativePath: $relativePath,
          params: $params
        ){__typename}
      }`, {
      variables: {
        collection: collectionName,
        relativePath,
        params
      }
    });
    return response;
  }
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const AuthWallInner = ({
  children,
  cms,
  loginScreen,
  getModalActions
}) => {
  var _a, _b, _c, _d, _e;
  const client = cms.api.tina;
  const isTinaCloud = !client.isLocalMode && !((_e = (_d = (_c = (_b = (_a = client.schema) == null ? void 0 : _a.config) == null ? void 0 : _b.config) == null ? void 0 : _c.admin) == null ? void 0 : _d.auth) == null ? void 0 : _e.customAuth);
  const [activeModal, setActiveModal] = useState(null);
  const [showChildren, setShowChildren] = useState(false);
  React.useEffect(() => {
    client.isAuthenticated().then((isAuthenticated) => {
      if (isAuthenticated) {
        setShowChildren(true);
        cms.enable();
      } else {
        sleep(500).then(() => {
          setActiveModal("authenticate");
        });
      }
    });
  }, []);
  const onAuthSuccess = async () => {
    if (await client.isAuthenticated()) {
      setShowChildren(true);
      setActiveModal(null);
    } else {
      throw new Error("No access to repo");
    }
  };
  const otherModalActions = getModalActions ? getModalActions({
    closeModal: () => {
      setActiveModal(null);
    }
  }) : [];
  return /* @__PURE__ */ React.createElement(React.Fragment, null, activeModal === "authenticate" && /* @__PURE__ */ React.createElement(ModalBuilder, {
    title: isTinaCloud ? "Tina Cloud Authorization" : "Enter into edit mode",
    message: isTinaCloud ? "To save edits, Tina Cloud authorization is required. On save, changes will get commited using your account." : "To save edits, enter into edit mode. On save, changes will saved to the local filesystem.",
    close,
    actions: [
      ...otherModalActions,
      {
        action: async () => {
          setEditing(false);
          window.location.reload();
        },
        name: "Close",
        primary: false
      },
      {
        name: isTinaCloud ? "Continue to Tina Cloud" : "Enter Edit Mode",
        action: async () => {
          const token = await client.authenticate();
          if (typeof (client == null ? void 0 : client.onLogin) === "function") {
            await (client == null ? void 0 : client.onLogin({ token }));
          }
          onAuthSuccess();
        },
        primary: true
      }
    ]
  }), showChildren ? children : loginScreen ? loginScreen : null);
};
const TinaCloudProvider = (props) => {
  const baseBranch = props.branch || "main";
  const [currentBranch, setCurrentBranch] = useLocalStorage("tinacms-current-branch", baseBranch);
  useTinaAuthRedirect();
  const cms = React.useMemo(() => props.cms || new TinaCMS({
    enabled: true,
    sidebar: true,
    isLocalClient: props.isLocalClient,
    clientId: props.clientId
  }), [props.cms]);
  if (!cms.api.tina) {
    cms.registerApi("tina", createClient({ ...props, branch: currentBranch }));
  } else {
    cms.api.tina.setBranch(currentBranch);
  }
  if (!cms.api.admin) {
    cms.registerApi("admin", new TinaAdminApi(cms));
  }
  const setupMedia = async () => {
    var _a, _b, _c, _d, _e, _f, _g;
    const hasTinaMedia = Boolean((_b = (_a = props.schema.config) == null ? void 0 : _a.media) == null ? void 0 : _b.tina);
    if (hasTinaMedia) {
      cms.media.store = new TinaMediaStore(cms);
    } else if (((_d = (_c = props.schema.config) == null ? void 0 : _c.media) == null ? void 0 : _d.loadCustomStore) || props.mediaStore) {
      const mediaStoreFromProps = ((_f = (_e = props.schema.config) == null ? void 0 : _e.media) == null ? void 0 : _f.loadCustomStore) || props.mediaStore;
      if ((_g = mediaStoreFromProps.prototype) == null ? void 0 : _g.persist) {
        cms.media.store = new mediaStoreFromProps(cms.api.tina);
      } else {
        const MediaClass = await mediaStoreFromProps();
        cms.media.store = new MediaClass(cms.api.tina);
      }
    } else {
      cms.media.store = new DummyMediaStore();
    }
  };
  const handleListBranches = async () => {
    const { owner, repo } = props;
    const branches = await cms.api.tina.listBranches({ owner, repo });
    if (!Array.isArray(branches)) {
      return [];
    }
    return branches;
  };
  const handleCreateBranch = async (data) => {
    const newBranch = await cms.api.tina.createBranch(data);
    return newBranch;
  };
  setupMedia();
  const [branchingEnabled, setBranchingEnabled] = React.useState(() => cms.flags.get("branch-switcher"));
  React.useEffect(() => {
    cms.events.subscribe("flag:set", ({ key, value }) => {
      if (key === "branch-switcher") {
        setBranchingEnabled(value);
      }
    });
  }, [cms.events]);
  React.useEffect(() => {
    let branchSwitcher;
    if (branchingEnabled) {
      branchSwitcher = new BranchSwitcherPlugin({
        listBranches: handleListBranches,
        createBranch: handleCreateBranch
      });
      cms.plugins.add(branchSwitcher);
    }
    return () => {
      if (branchingEnabled && branchSwitcher) {
        cms.plugins.remove(branchSwitcher);
      }
    };
  }, [branchingEnabled, props.branch]);
  React.useEffect(() => {
    if (props.cmsCallback) {
      props.cmsCallback(cms);
    }
  }, []);
  return /* @__PURE__ */ React.createElement(BranchDataProvider, {
    currentBranch,
    setCurrentBranch: (b) => {
      setCurrentBranch(b);
    }
  }, /* @__PURE__ */ React.createElement(TinaProvider, {
    cms
  }, /* @__PURE__ */ React.createElement(AuthWallInner, {
    ...props,
    cms
  })));
};
const TinaCloudAuthWall = TinaCloudProvider;
var styles = `.tina-tailwind {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  -moz-tab-size: 4;
  tab-size: 4;
}

  .tina-tailwind *,
  .tina-tailwind ::before,
  .tina-tailwind ::after {
    box-sizing: border-box;
    border-width: 0;
    border-style: solid;
    border-color: transparent;
  }

  .tina-tailwind ::before,
  .tina-tailwind ::after {
    --tw-content: '';
  }

  .tina-tailwind hr {
    height: 0; /* 1 */
    color: inherit; /* 2 */
    border-top-width: 1px; /* 3 */
  }

  .tina-tailwind abbr:where([title]) {
    text-decoration: underline dotted;
  }

  .tina-tailwind h1,
  .tina-tailwind h2,
  .tina-tailwind h3,
  .tina-tailwind h4,
  .tina-tailwind h5,
  .tina-tailwind h6 {
    font-size: inherit;
    font-weight: inherit;
  }

  .tina-tailwind a {
    color: inherit;
    text-decoration: inherit;
  }

  .tina-tailwind b,
  .tina-tailwind strong {
    font-weight: bolder;
  }

  .tina-tailwind code,
  .tina-tailwind kbd,
  .tina-tailwind samp,
  .tina-tailwind pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* 1 */
    font-size: 1em; /* 2 */
  }

  .tina-tailwind small {
    font-size: 80%;
  }

  .tina-tailwind sub,
  .tina-tailwind sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
  }

  .tina-tailwind sub {
    bottom: -0.25em;
  }

  .tina-tailwind sup {
    top: -0.5em;
  }

  .tina-tailwind table {
    text-indent: 0; /* 1 */
    border-color: inherit; /* 2 */
    border-collapse: collapse; /* 3 */
  }

  .tina-tailwind button,
  .tina-tailwind input,
  .tina-tailwind optgroup,
  .tina-tailwind select,
  .tina-tailwind textarea {
    font-family: inherit; /* 1 */
    font-size: 100%; /* 1 */
    line-height: inherit; /* 1 */
    color: inherit; /* 1 */
    margin: 0; /* 2 */
    padding: 0; /* 3 */
  }

  .tina-tailwind button,
  .tina-tailwind select {
    text-transform: none;
  }

  .tina-tailwind button,
  .tina-tailwind [type='button'],
  .tina-tailwind [type='reset'],
  .tina-tailwind [type='submit'] {
    -webkit-appearance: button; /* 1 */
    background-color: transparent; /* 2 */
    background-image: none; /* 2 */
  }

  .tina-tailwind :-moz-focusring {
    outline: auto;
  }

  .tina-tailwind :-moz-ui-invalid {
    box-shadow: none;
  }

  .tina-tailwind progress {
    vertical-align: baseline;
  }

  .tina-tailwind ::-webkit-inner-spin-button,
  .tina-tailwind ::-webkit-outer-spin-button {
    height: auto;
  }

  .tina-tailwind [type='search'] {
    -webkit-appearance: textfield; /* 1 */
    outline-offset: -2px; /* 2 */
  }

  .tina-tailwind ::-webkit-search-decoration {
    -webkit-appearance: none;
  }

  .tina-tailwind ::-webkit-file-upload-button {
    -webkit-appearance: button; /* 1 */
    font: inherit; /* 2 */
  }

  .tina-tailwind summary {
    display: list-item;
  }

  .tina-tailwind blockquote,
  .tina-tailwind dl,
  .tina-tailwind dd,
  .tina-tailwind h1,
  .tina-tailwind h2,
  .tina-tailwind h3,
  .tina-tailwind h4,
  .tina-tailwind h5,
  .tina-tailwind h6,
  .tina-tailwind hr,
  .tina-tailwind figure,
  .tina-tailwind p,
  .tina-tailwind pre {
    margin: 0;
  }

  .tina-tailwind fieldset {
    margin: 0;
    padding: 0;
  }

  .tina-tailwind legend {
    padding: 0;
  }

  .tina-tailwind ol,
  .tina-tailwind ul,
  .tina-tailwind menu {
    list-style: none;
    margin: 0;
    padding: 0;
  }

  .tina-tailwind li:before {
    display: none;
  }

  .tina-tailwind textarea {
    resize: vertical;
  }

  .tina-tailwind input::placeholder,
  .tina-tailwind textarea::placeholder {
    opacity: 1; /* 1 */
    color: #918c9e; /* 2 */
  }

  .tina-tailwind button,
  .tina-tailwind [role='button'] {
    cursor: pointer;
  }

  .tina-tailwind :disabled {
    cursor: default;
  }

  .tina-tailwind img,
  .tina-tailwind svg,
  .tina-tailwind video,
  .tina-tailwind canvas,
  .tina-tailwind audio,
  .tina-tailwind iframe,
  .tina-tailwind embed,
  .tina-tailwind object {
    display: block; /* 1 */
    vertical-align: middle; /* 2 */
  }

  .tina-tailwind img,
  .tina-tailwind video {
    max-width: 100%;
    height: auto;
  }

  .tina-tailwind [hidden] {
    display: none;
  }
*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(0 132 255 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}
::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(0 132 255 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}
.tina-tailwind .pointer-events-none {
  pointer-events: none;
}
.tina-tailwind .pointer-events-auto {
  pointer-events: auto;
}
.tina-tailwind .static {
  position: static;
}
.tina-tailwind .fixed {
  position: fixed;
}
.tina-tailwind .absolute {
  position: absolute;
}
.tina-tailwind .relative {
  position: relative;
}
.tina-tailwind .inset-0 {
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
}
.tina-tailwind .left-0 {
  left: 0px;
}
.tina-tailwind .top-0 {
  top: 0px;
}
.tina-tailwind .top-8 {
  top: 32px;
}
.tina-tailwind .right-0 {
  right: 0px;
}
.tina-tailwind .top-10 {
  top: 40px;
}
.tina-tailwind .top-4 {
  top: 16px;
}
.tina-tailwind .top-1\\/2 {
  top: 50%;
}
.tina-tailwind .left-2 {
  left: 8px;
}
.tina-tailwind .z-overlay {
  z-index: 10600;
}
.tina-tailwind .z-menu {
  z-index: 9800;
}
.tina-tailwind .z-50 {
  z-index: 50;
}
.tina-tailwind .mx-auto {
  margin-left: auto;
  margin-right: auto;
}
.tina-tailwind .-ml-px {
  margin-left: -1px;
}
.tina-tailwind .mr-2 {
  margin-right: 8px;
}
.tina-tailwind .ml-1 {
  margin-left: 4px;
}
.tina-tailwind .mb-2 {
  margin-bottom: 8px;
}
.tina-tailwind .mb-1 {
  margin-bottom: 4px;
}
.tina-tailwind .-mt-0\\.5 {
  margin-top: -2px;
}
.tina-tailwind .-mt-0 {
  margin-top: -0px;
}
.tina-tailwind .mt-2 {
  margin-top: 8px;
}
.tina-tailwind .ml-1\\.5 {
  margin-left: 6px;
}
.tina-tailwind .mb-4 {
  margin-bottom: 16px;
}
.tina-tailwind .mr-1\\.5 {
  margin-right: 6px;
}
.tina-tailwind .mr-1 {
  margin-right: 4px;
}
.tina-tailwind .block {
  display: block;
}
.tina-tailwind .inline-block {
  display: inline-block;
}
.tina-tailwind .inline {
  display: inline;
}
.tina-tailwind .flex {
  display: flex;
}
.tina-tailwind .inline-flex {
  display: inline-flex;
}
.tina-tailwind .table {
  display: table;
}
.tina-tailwind .grid {
  display: grid;
}
.tina-tailwind .h-screen {
  height: 100vh;
}
.tina-tailwind .h-auto {
  height: auto;
}
.tina-tailwind .h-full {
  height: 100%;
}
.tina-tailwind .h-6 {
  height: 24px;
}
.tina-tailwind .h-7 {
  height: 28px;
}
.tina-tailwind .h-5 {
  height: 20px;
}
.tina-tailwind .h-10 {
  height: 40px;
}
.tina-tailwind .h-12 {
  height: 48px;
}
.tina-tailwind .w-full {
  width: 100%;
}
.tina-tailwind .w-10 {
  width: 40px;
}
.tina-tailwind .w-auto {
  width: auto;
}
.tina-tailwind .w-5 {
  width: 20px;
}
.tina-tailwind .w-56 {
  width: 224px;
}
.tina-tailwind .w-\\[15\\%\\] {
  width: 15%;
}
.tina-tailwind .w-0 {
  width: 0px;
}
.tina-tailwind .w-6 {
  width: 24px;
}
.tina-tailwind .max-w-lg {
  max-width: 32rem;
}
.tina-tailwind .max-w-screen-xl {
  max-width: 1280px;
}
.tina-tailwind .max-w-form {
  max-width: 900px;
}
.tina-tailwind .max-w-full {
  max-width: 100%;
}
.tina-tailwind .max-w-0 {
  max-width: 0rem;
}
.tina-tailwind .flex-1 {
  flex: 1 1 0%;
}
.tina-tailwind .flex-shrink-0 {
  flex-shrink: 0;
}
.tina-tailwind .flex-grow-0 {
  flex-grow: 0;
}
.tina-tailwind .table-auto {
  table-layout: auto;
}
.tina-tailwind .origin-top-right {
  transform-origin: top right;
}
.tina-tailwind .-translate-x-full {
  --tw-translate-x: -100%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tina-tailwind .translate-x-0 {
  --tw-translate-x: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tina-tailwind .translate-x-full {
  --tw-translate-x: 100%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tina-tailwind .-translate-y-1\\/2 {
  --tw-translate-y: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tina-tailwind .scale-95 {
  --tw-scale-x: .95;
  --tw-scale-y: .95;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tina-tailwind .scale-100 {
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tina-tailwind .transform {
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tina-tailwind .cursor-pointer {
  cursor: pointer;
}
.tina-tailwind .grid-flow-col {
  grid-auto-flow: column;
}
.tina-tailwind .flex-col {
  flex-direction: column;
}
.tina-tailwind .flex-wrap {
  flex-wrap: wrap;
}
.tina-tailwind .items-start {
  align-items: flex-start;
}
.tina-tailwind .items-end {
  align-items: flex-end;
}
.tina-tailwind .items-center {
  align-items: center;
}
.tina-tailwind .items-stretch {
  align-items: stretch;
}
.tina-tailwind .justify-end {
  justify-content: flex-end;
}
.tina-tailwind .justify-center {
  justify-content: center;
}
.tina-tailwind .justify-between {
  justify-content: space-between;
}
.tina-tailwind .gap-0\\.5 {
  gap: 2px;
}
.tina-tailwind .gap-0 {
  gap: 0px;
}
.tina-tailwind .gap-4 {
  gap: 16px;
}
.tina-tailwind .gap-2 {
  gap: 8px;
}
.tina-tailwind .gap-3 {
  gap: 12px;
}
.tina-tailwind .divide-y > :not([hidden]) ~ :not([hidden]) {
  --tw-divide-y-reverse: 0;
  border-top-width: calc(1px * calc(1 - var(--tw-divide-y-reverse)));
  border-bottom-width: calc(1px * var(--tw-divide-y-reverse));
}
.tina-tailwind .divide-gray-150 > :not([hidden]) ~ :not([hidden]) {
  --tw-divide-opacity: 1;
  border-color: rgb(230 227 239 / var(--tw-divide-opacity));
}
.tina-tailwind .self-end {
  align-self: flex-end;
}
.tina-tailwind .justify-self-end {
  justify-self: end;
}
.tina-tailwind .overflow-hidden {
  overflow: hidden;
}
.tina-tailwind .overflow-y-auto {
  overflow-y: auto;
}
.tina-tailwind .truncate {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.tina-tailwind .whitespace-normal {
  white-space: normal;
}
.tina-tailwind .whitespace-nowrap {
  white-space: nowrap;
}
.tina-tailwind .rounded-lg {
  border-radius: 8px;
}
.tina-tailwind .rounded {
  border-radius: 4px;
}
.tina-tailwind .rounded-md {
  border-radius: 6px;
}
.tina-tailwind .rounded-full {
  border-radius: 9999px;
}
.tina-tailwind .rounded-r-md {
  border-top-right-radius: 6px;
  border-bottom-right-radius: 6px;
}
.tina-tailwind .border {
  border-width: 1px;
}
.tina-tailwind .border-b {
  border-bottom-width: 1px;
}
.tina-tailwind .border-gray-150 {
  --tw-border-opacity: 1;
  border-color: rgb(230 227 239 / var(--tw-border-opacity));
}
.tina-tailwind .border-gray-200 {
  --tw-border-opacity: 1;
  border-color: rgb(225 221 236 / var(--tw-border-opacity));
}
.tina-tailwind .bg-white {
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity));
}
.tina-tailwind .bg-gray-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(246 246 249 / var(--tw-bg-opacity));
}
.tina-tailwind .bg-blue-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(0 132 255 / var(--tw-bg-opacity));
}
.tina-tailwind .bg-gradient-to-b {
  background-image: linear-gradient(to bottom, var(--tw-gradient-stops));
}
.tina-tailwind .bg-gradient-to-br {
  background-image: linear-gradient(to bottom right, var(--tw-gradient-stops));
}
.tina-tailwind .from-blue-900 {
  --tw-gradient-from: #1D2C6C;
  --tw-gradient-to: rgb(29 44 108 / 0);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}
.tina-tailwind .from-gray-50\\/50 {
  --tw-gradient-from: rgb(246 246 249 / .5);
  --tw-gradient-to: rgb(246 246 249 / 0);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}
.tina-tailwind .from-gray-800 {
  --tw-gradient-from: #363145;
  --tw-gradient-to: rgb(54 49 69 / 0);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}
.tina-tailwind .via-gray-900 {
  --tw-gradient-to: rgb(37 35 54 / 0);
  --tw-gradient-stops: var(--tw-gradient-from), #252336, var(--tw-gradient-to);
}
.tina-tailwind .to-gray-900 {
  --tw-gradient-to: #252336;
}
.tina-tailwind .to-gray-50 {
  --tw-gradient-to: #F6F6F9;
}
.tina-tailwind .to-black {
  --tw-gradient-to: #000;
}
.tina-tailwind .px-4 {
  padding-left: 16px;
  padding-right: 16px;
}
.tina-tailwind .py-6 {
  padding-top: 24px;
  padding-bottom: 24px;
}
.tina-tailwind .px-5 {
  padding-left: 20px;
  padding-right: 20px;
}
.tina-tailwind .py-4 {
  padding-top: 16px;
  padding-bottom: 16px;
}
.tina-tailwind .px-12 {
  padding-left: 48px;
  padding-right: 48px;
}
.tina-tailwind .py-8 {
  padding-top: 32px;
  padding-bottom: 32px;
}
.tina-tailwind .py-10 {
  padding-top: 40px;
  padding-bottom: 40px;
}
.tina-tailwind .py-2 {
  padding-top: 8px;
  padding-bottom: 8px;
}
.tina-tailwind .px-20 {
  padding-left: 80px;
  padding-right: 80px;
}
.tina-tailwind .px-6 {
  padding-left: 24px;
  padding-right: 24px;
}
.tina-tailwind .py-1 {
  padding-top: 4px;
  padding-bottom: 4px;
}
.tina-tailwind .px-3 {
  padding-left: 12px;
  padding-right: 12px;
}
.tina-tailwind .py-5 {
  padding-top: 20px;
  padding-bottom: 20px;
}
.tina-tailwind .pt-4 {
  padding-top: 16px;
}
.tina-tailwind .pt-12 {
  padding-top: 48px;
}
.tina-tailwind .pr-3 {
  padding-right: 12px;
}
.tina-tailwind .pl-8 {
  padding-left: 32px;
}
.tina-tailwind .pl-3 {
  padding-left: 12px;
}
.tina-tailwind .pl-5 {
  padding-left: 20px;
}
.tina-tailwind .pl-18 {
  padding-left: 72px;
}
.tina-tailwind .text-left {
  text-align: left;
}
.tina-tailwind .text-center {
  text-align: center;
}
.tina-tailwind .font-sans {
  font-family: Inter, ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.tina-tailwind .text-2xl {
  font-size: 24px;
  line-height: 1.33;
}
.tina-tailwind .text-base {
  font-size: 16px;
  line-height: 1.5;
}
.tina-tailwind .text-sm {
  font-size: 14px;
  line-height: 1.43;
}
.tina-tailwind .text-xl {
  font-size: 20px;
  line-height: 1.4;
}
.tina-tailwind .text-md {
  font-size: 16px;
  line-height: 1.5;
}
.tina-tailwind .text-xs {
  font-size: 13px;
  line-height: 1.33;
}
.tina-tailwind .font-medium {
  font-weight: 500;
}
.tina-tailwind .font-semibold {
  font-weight: 600;
}
.tina-tailwind .uppercase {
  text-transform: uppercase;
}
.tina-tailwind .italic {
  font-style: italic;
}
.tina-tailwind .leading-normal {
  line-height: 1.5;
}
.tina-tailwind .leading-tight {
  line-height: 1.25;
}
.tina-tailwind .leading-5 {
  line-height: 20px;
}
.tina-tailwind .tracking-wide {
  letter-spacing: 0.025em;
}
.tina-tailwind .text-gray-600 {
  --tw-text-opacity: 1;
  color: rgb(86 81 101 / var(--tw-text-opacity));
}
.tina-tailwind .text-gray-700 {
  --tw-text-opacity: 1;
  color: rgb(67 62 82 / var(--tw-text-opacity));
}
.tina-tailwind .text-blue-600 {
  --tw-text-opacity: 1;
  color: rgb(5 116 228 / var(--tw-text-opacity));
}
.tina-tailwind .text-gray-500 {
  --tw-text-opacity: 1;
  color: rgb(113 108 127 / var(--tw-text-opacity));
}
.tina-tailwind .text-gray-300 {
  --tw-text-opacity: 1;
  color: rgb(178 173 190 / var(--tw-text-opacity));
}
.tina-tailwind .text-gray-400 {
  --tw-text-opacity: 1;
  color: rgb(145 140 158 / var(--tw-text-opacity));
}
.tina-tailwind .text-blue-500 {
  --tw-text-opacity: 1;
  color: rgb(0 132 255 / var(--tw-text-opacity));
}
.tina-tailwind .text-current {
  color: currentColor;
}
.tina-tailwind .text-white {
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity));
}
.tina-tailwind .text-gray-800 {
  --tw-text-opacity: 1;
  color: rgb(54 49 69 / var(--tw-text-opacity));
}
.tina-tailwind .text-gray-900 {
  --tw-text-opacity: 1;
  color: rgb(37 35 54 / var(--tw-text-opacity));
}
.tina-tailwind .text-red-500 {
  --tw-text-opacity: 1;
  color: rgb(239 68 68 / var(--tw-text-opacity));
}
.tina-tailwind .underline {
  text-decoration-line: underline;
}
.tina-tailwind .opacity-100 {
  opacity: 1;
}
.tina-tailwind .opacity-0 {
  opacity: 0;
}
.tina-tailwind .opacity-80 {
  opacity: .8;
}
.tina-tailwind .opacity-90 {
  opacity: .9;
}
.tina-tailwind .opacity-20 {
  opacity: .2;
}
.tina-tailwind .opacity-50 {
  opacity: .5;
}
.tina-tailwind .opacity-70 {
  opacity: .7;
}
.tina-tailwind .shadow-lg {
  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tina-tailwind .shadow-2xl {
  --tw-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
  --tw-shadow-colored: 0 25px 50px -12px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tina-tailwind .shadow-inner {
  --tw-shadow: inset 0 2px 4px 0 rgb(0 0 0 / 0.05);
  --tw-shadow-colored: inset 0 2px 4px 0 var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tina-tailwind .shadow {
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tina-tailwind .ring-1 {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.tina-tailwind .ring-black {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(0 0 0 / var(--tw-ring-opacity));
}
.tina-tailwind .ring-opacity-5 {
  --tw-ring-opacity: .05;
}
.tina-tailwind .filter {
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.tina-tailwind .transition-opacity {
  transition-property: opacity;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tina-tailwind .transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tina-tailwind .transition-colors {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tina-tailwind .transition {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tina-tailwind .duration-300 {
  transition-duration: 300ms;
}
.tina-tailwind .duration-200 {
  transition-duration: 200ms;
}
.tina-tailwind .duration-150 {
  transition-duration: 150ms;
}
.tina-tailwind .duration-100 {
  transition-duration: 100ms;
}
.tina-tailwind .duration-75 {
  transition-duration: 75ms;
}
.tina-tailwind .ease-out {
  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);
}
.tina-tailwind .ease-in {
  transition-timing-function: cubic-bezier(0.4, 0, 1, 1);
}
.tina-tailwind .icon-parent svg {
      fill: currentColor;
    }
.tina-tailwind {
  font-family: Inter, ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  font-size: 16px;
  line-height: 1.5;
  --tw-text-opacity: 1;
  color: rgb(86 81 101 / var(--tw-text-opacity));
}
.tina-tailwind .hover\\:bg-blue-600:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(5 116 228 / var(--tw-bg-opacity));
}
.tina-tailwind .hover\\:text-blue-600:hover {
  --tw-text-opacity: 1;
  color: rgb(5 116 228 / var(--tw-text-opacity));
}
.tina-tailwind .hover\\:text-blue-400:hover {
  --tw-text-opacity: 1;
  color: rgb(34 150 254 / var(--tw-text-opacity));
}
.tina-tailwind .hover\\:opacity-100:hover {
  opacity: 1;
}
.tina-tailwind .hover\\:opacity-60:hover {
  opacity: .6;
}
.tina-tailwind .focus\\:border-blue-500:focus {
  --tw-border-opacity: 1;
  border-color: rgb(0 132 255 / var(--tw-border-opacity));
}
.tina-tailwind .focus\\:text-gray-900:focus {
  --tw-text-opacity: 1;
  color: rgb(37 35 54 / var(--tw-text-opacity));
}
.tina-tailwind .focus\\:text-blue-400:focus {
  --tw-text-opacity: 1;
  color: rgb(34 150 254 / var(--tw-text-opacity));
}
.tina-tailwind .focus\\:underline:focus {
  text-decoration-line: underline;
}
.tina-tailwind .focus\\:shadow-outline:focus {
  --tw-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
  --tw-shadow-colored: 0 0 0 3px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tina-tailwind .focus\\:outline-none:focus {
  outline: 2px solid transparent;
  outline-offset: 2px;
}
.tina-tailwind .focus\\:ring-2:focus {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.tina-tailwind .focus\\:ring-blue-500:focus {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(0 132 255 / var(--tw-ring-opacity));
}
.tina-tailwind .group:hover .group-hover\\:border-gray-200 {
  --tw-border-opacity: 1;
  border-color: rgb(225 221 236 / var(--tw-border-opacity));
}
.tina-tailwind .group:hover .group-hover\\:bg-white {
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity));
}
.tina-tailwind .group:hover .group-hover\\:text-gray-600 {
  --tw-text-opacity: 1;
  color: rgb(86 81 101 / var(--tw-text-opacity));
}
.tina-tailwind .group:hover .group-hover\\:opacity-0 {
  opacity: 0;
}
.tina-tailwind .group:hover .group-hover\\:opacity-80 {
  opacity: .8;
}
.tina-tailwind .group:active .group-active\\:opacity-0 {
  opacity: 0;
}
.tina-tailwind .group:active .group-active\\:opacity-80 {
  opacity: .8;
}
`;
class ContentCreatorPlugin {
  constructor(options) {
    this.__type = "content-creator";
    this.fields = options.fields;
    this.name = options.label;
    this.onNewDocument = options.onNewDocument;
    this.collections = options.collections;
    this.onChange = options.onChange;
    this.initialValues = options.initialValues;
  }
  async onSubmit({ collection, template, relativePath }, cms) {
    try {
      const selectedCollection = this.collections.find((collectionItem) => collectionItem.slug === collection);
      const collectionFormat = selectedCollection.format;
      const extensionLength = -1 * (collectionFormat.length + 1);
      let relativePathWithExt = relativePath;
      if (relativePath.slice(extensionLength).toLocaleLowerCase() === `.${collectionFormat}`) {
        relativePathWithExt = `${relativePath.slice(0, -3)}.${collectionFormat}`;
      } else {
        relativePathWithExt = `${relativePath}.${collectionFormat}`;
      }
      const payload = {
        relativePath: relativePathWithExt,
        collection,
        template
      };
      try {
        const res = await cms.api.tina.addPendingContent(payload);
        if (res.errors) {
          res.errors.map((e) => {
            cms.alerts.error(e.message);
          });
        } else {
          cms.alerts.info("Document created!");
          if (typeof this.onNewDocument === "function") {
            this.onNewDocument(res.addPendingDocument._sys);
          }
        }
      } catch (e) {
        cms.alerts.error(e.message);
      }
    } catch (e) {
      cms.alerts.error(e.message);
    }
  }
}
const useDocumentCreatorPlugin = (args) => {
  const cms = useCMS();
  const [values, setValues] = React.useState({});
  const [plugin, setPlugin] = React.useState(null);
  React.useEffect(() => {
    const run = async () => {
      var _a;
      const res = await cms.api.tina.request((gql2) => gql2`
          {
            collections {
              label
              slug
              format
              templates
            }
          }
        `, { variables: {} });
      const allCollectionOptions = [];
      res.collections.forEach((collection) => {
        const value = collection.slug;
        const label = `${collection.label}`;
        allCollectionOptions.push({ value, label });
      });
      let collectionOptions;
      if (args && args.filterCollections && typeof args.filterCollections === "function") {
        const filtered = args.filterCollections(allCollectionOptions);
        collectionOptions = [
          { value: "", label: "Choose Collection" },
          ...filtered
        ];
      } else {
        collectionOptions = [
          { value: "", label: "Choose Collection" },
          ...allCollectionOptions
        ];
      }
      const templateOptions = [
        { value: "", label: "Choose Template" }
      ];
      if (values.collection) {
        const filteredCollection = res.collections.find((c) => c.slug === values.collection);
        (_a = filteredCollection == null ? void 0 : filteredCollection.templates) == null ? void 0 : _a.forEach((template) => {
          templateOptions.push({ value: template.name, label: template.label });
        });
      }
      setPlugin(new ContentCreatorPlugin({
        label: "Add Document",
        onNewDocument: args && args.onNewDocument,
        collections: res.collections,
        onChange: async ({ values: values2 }) => {
          setValues(values2);
        },
        initialValues: values,
        fields: [
          {
            component: "select",
            name: "collection",
            label: "Collection",
            description: "Select the collection.",
            options: collectionOptions,
            validate: async (value, allValues, meta) => {
              if (!value) {
                return true;
              }
            }
          },
          {
            component: "select",
            name: "template",
            label: "Template",
            description: "Select the template.",
            options: templateOptions,
            validate: async (value, allValues, meta) => {
              if (!value && templateOptions.length > 1) {
                if (meta.dirty) {
                  return "Required";
                }
                return true;
              }
            }
          },
          {
            component: "text",
            name: "relativePath",
            label: "Name",
            description: `A unique name for the content. Example: "newPost" or "blog_022021`,
            placeholder: "newPost",
            validate: (value, allValues, meta) => {
              if (!value) {
                if (meta.dirty) {
                  return "Required";
                }
                return true;
              }
              const isValid = /^[_a-zA-Z0-9][\-_a-zA-Z0-9]*$/.test(value);
              if (value && !isValid) {
                return "Must begin with a-z, A-Z, 0-9, or _ and contain only a-z, A-Z, 0-9, - or _";
              }
            }
          }
        ]
      }));
    };
    run();
  }, [cms]);
  React.useEffect(() => {
    if (plugin) {
      cms.plugins.add(plugin);
    }
    return () => {
      if (plugin) {
        cms.plugins.remove(plugin);
      }
    };
  }, [plugin]);
};
function useTina({
  query,
  variables,
  data
}) {
  React.useEffect(() => {
    console.warn(`
  "useTina" from 'tinacms/dist/edit-state' is now deprecated
  * Use "import { useTina } from 'tinacms/dist/react" instead.
  * See https://tina.io/blog/upgrading-to-iframe/ for full migration details
  `);
  }, []);
  const {
    setRequest,
    state,
    isDummyContainer,
    isLoading: contextLoading
  } = React.useContext(TinaDataContext);
  const [waitForContextRerender, setWaitForContextRerender] = useState(!isDummyContainer);
  const isLoading = contextLoading || waitForContextRerender;
  React.useEffect(() => {
    setRequest({ query, variables });
  }, [JSON.stringify(variables), query]);
  useEffect(() => {
    if (!isDummyContainer) {
      setTimeout(() => setWaitForContextRerender(false), 0);
    }
    return () => {
      setRequest(void 0);
    };
  }, [isDummyContainer]);
  return {
    data: isDummyContainer || isLoading ? data : state.payload,
    isLoading
  };
}
const errorButtonStyles = {
  background: "#eb6337",
  padding: "12px 18px",
  cursor: "pointer",
  borderRadius: "50px",
  textTransform: "uppercase",
  letterSpacing: "2px",
  fontWeight: "bold",
  border: "none",
  color: "white",
  margin: "1rem 0"
};
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: props.hasError,
      message: "",
      pageRefresh: false
    };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, message: error.message };
  }
  render() {
    const branchData = window.localStorage && window.localStorage.getItem("tinacms-current-branch");
    const hasBranchData = branchData && branchData.length > 0;
    if (this.state.hasError && !this.state.pageRefresh) {
      return /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#efefef",
          height: "100vh",
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        }
      }, /* @__PURE__ */ React.createElement("style", null, "            body {              margin: 0;            }          "), /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#fff",
          maxWidth: "400px",
          padding: "20px",
          fontFamily: "'Inter', sans-serif",
          borderRadius: "5px",
          boxShadow: "0 6px 24px rgb(0 37 91 / 5%), 0 2px 4px rgb(0 37 91 / 3%)"
        }
      }, /* @__PURE__ */ React.createElement("h3", {
        style: { color: "#eb6337" }
      }, "TinaCMS Render Error"), /* @__PURE__ */ React.createElement("p", null, "Tina caught an error while updating the page:"), /* @__PURE__ */ React.createElement("pre", {
        style: { marginTop: "1rem", overflowX: "auto" }
      }, this.state.message), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("p", null, `If you've just updated the form, undo your most recent changes and click "refresh". If after a few refreshes, you're still encountering this error. There is a bigger issue with the site. Please reach out to your site admin.`), /* @__PURE__ */ React.createElement("p", null, "See our", " ", /* @__PURE__ */ React.createElement("a", {
        className: "text-gray-600",
        style: { textDecoration: "underline" },
        href: "https://tina.io/docs/errors/faq/",
        target: "_blank"
      }, " ", "Error FAQ", " "), " ", "for more information."), /* @__PURE__ */ React.createElement("button", {
        style: errorButtonStyles,
        onClick: () => {
          this.setState({ pageRefresh: true });
          setTimeout(() => this.setState({ hasError: false, pageRefresh: false }), 3e3);
        }
      }, "Refresh"), hasBranchData && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("p", null, `If you're using the branch switcher, you may currently be on a "stale" branch that has been deleted or whose content is not compatible with the latest version of the site's layout. Click the button below to switch back to the default branch for this deployment.`), /* @__PURE__ */ React.createElement("p", null, "See our", " ", /* @__PURE__ */ React.createElement("a", {
        className: "text-gray-600",
        style: { textDecoration: "underline" },
        href: "https://tina.io/docs/errors/faq/",
        target: "_blank"
      }, " ", "Error FAQ", " "), " ", "for more information."), /* @__PURE__ */ React.createElement("button", {
        style: errorButtonStyles,
        onClick: () => {
          window.localStorage.removeItem("tinacms-current-branch");
          window.location.reload();
        }
      }, "Switch to default branch"))));
    }
    if (this.state.pageRefresh) {
      return /* @__PURE__ */ React.createElement(Loader, null, "Let's try that again.");
    }
    return this.props.children;
  }
}
const TinaCMSProvider2 = ({
  query,
  documentCreatorCallback,
  formifyCallback,
  schema,
  ...props
}) => {
  var _a, _b, _c, _d, _e;
  React.useEffect(() => {
    console.warn(`
    * Tina no longer requires wrapping your site in the TinaProvider
    * See https://tina.io/blog/upgrading-to-iframe/ for full migration details
    `);
  }, []);
  if (props == null ? void 0 : props.apiURL) {
    console.warn("The apiURL prop is deprecated. Please see https://tina.io/blog/tina-v-0.68.14 for information on how to upgrade to the new API");
  }
  const apiURL = ((_a = props == null ? void 0 : props.client) == null ? void 0 : _a.apiUrl) || (props == null ? void 0 : props.apiURL);
  const isLocalOverride = (_d = (_c = (_b = schema == null ? void 0 : schema.config) == null ? void 0 : _b.admin) == null ? void 0 : _c.auth) == null ? void 0 : _d.useLocalAuth;
  const { branch, clientId, isLocalClient } = apiURL ? parseURL(apiURL) : {
    branch: props.branch,
    clientId: props.clientId,
    isLocalClient: props == null ? void 0 : props.isLocalClient
  };
  if (typeof isLocalClient === "undefined" || !isLocalClient && (!branch || !clientId) && !schema.config.contentApiUrlOverride) {
    throw new Error("Invalid setup. See https://tina.io/docs/tina-cloud/connecting-site/ for more information.");
  }
  if (!schema) {
    throw new Error("`schema` is required to be passed as a property to `TinaProvider`.  You can learn more about this change here: https://github.com/tinacms/tinacms/pull/2823");
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(TinaCloudProvider, {
    branch,
    clientId: clientId || ((_e = schema == null ? void 0 : schema.config) == null ? void 0 : _e.clientId),
    tinaioConfig: props.tinaioConfig,
    isLocalClient: isLocalOverride || isLocalClient,
    cmsCallback: props.cmsCallback,
    mediaStore: props.mediaStore,
    apiUrl: apiURL,
    schema: { ...schema, config: { ...schema.config, ...props } }
  }, /* @__PURE__ */ React.createElement("style", null, styles), /* @__PURE__ */ React.createElement(ErrorBoundary, null, /* @__PURE__ */ React.createElement(DocumentCreator, {
    documentCreatorCallback
  }), /* @__PURE__ */ React.createElement(TinaDataProvider, {
    formifyCallback
  }, typeof props.children == "function" ? /* @__PURE__ */ React.createElement(TinaQuery, {
    ...props,
    variables: props.variables,
    data: props.data,
    query,
    formifyCallback,
    children: props.children
  }) : props.children))));
};
const DocumentCreator = ({
  documentCreatorCallback
}) => {
  useDocumentCreatorPlugin(documentCreatorCallback);
  return null;
};
const TinaQuery = (props) => {
  return /* @__PURE__ */ React.createElement(TinaQueryInner, {
    key: `rootQuery-${props.query}`,
    ...props
  });
};
const TinaQueryInner = ({ children, ...props }) => {
  const { data: liveData, isLoading } = useTina({
    query: props.query,
    variables: props.variables,
    data: props.data
  });
  return /* @__PURE__ */ React.createElement(React.Fragment, null, children(isLoading || !props.query ? props : { ...props, data: liveData }));
};
const TinaDataProvider = ({
  children,
  formifyCallback
}) => {
  const [request, setRequest] = useState();
  const [state, setState] = React.useState({
    payload: void 0,
    isLoading: true
  });
  return /* @__PURE__ */ React.createElement(TinaDataContext.Provider, {
    value: {
      setRequest,
      isLoading: state.isLoading,
      state: { payload: state.payload }
    }
  }, /* @__PURE__ */ React.createElement(FormRegistrar, {
    key: request == null ? void 0 : request.query,
    request,
    formifyCallback,
    onPayloadStateChange: setState
  }), children);
};
const FormRegistrar = ({
  request,
  formifyCallback,
  onPayloadStateChange
}) => {
  const cms = useCMS();
  const { setFormsRegistering } = React.useContext(EditContext);
  const [payload, isLoading] = useGraphqlForms({
    query: request == null ? void 0 : request.query,
    variables: request == null ? void 0 : request.variables,
    formify: (args) => {
      if (formifyCallback) {
        return formifyCallback(args, cms);
      } else {
        return args.createForm(args.formConfig);
      }
    }
  });
  React.useEffect(() => {
    onPayloadStateChange({ payload, isLoading });
    setFormsRegistering && setFormsRegistering(isLoading);
  }, [JSON.stringify(payload), isLoading]);
  return isLoading ? /* @__PURE__ */ React.createElement(Loader, null, /* @__PURE__ */ React.createElement(React.Fragment, null)) : null;
};
const Loader = (props) => {
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    style: {
      position: "fixed",
      background: "rgba(0, 0, 0, 0.5)",
      inset: 0,
      zIndex: 200,
      opacity: "0.8",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      padding: "40px"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    style: {
      background: "#f6f6f9",
      boxShadow: "0px 2px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.1)",
      borderRadius: "5px",
      padding: "40px 32px",
      width: "460px",
      maxWidth: "90%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexDirection: "column"
    }
  }, /* @__PURE__ */ React.createElement("svg", {
    style: {
      width: "64px",
      color: "#2296fe",
      marginTop: "-8px",
      marginBottom: "16px"
    },
    version: "1.1",
    id: "L5",
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    x: "0px",
    y: "0px",
    viewBox: "0 0 100 64",
    enableBackground: "new 0 0 0 0",
    xmlSpace: "preserve"
  }, /* @__PURE__ */ React.createElement("circle", {
    fill: "currentColor",
    stroke: "none",
    cx: 6,
    cy: 32,
    r: 6
  }, /* @__PURE__ */ React.createElement("animateTransform", {
    attributeName: "transform",
    dur: "1s",
    type: "translate",
    values: "0 15 ; 0 -15; 0 15",
    calcMode: "spline",
    keySplines: "0.8 0 0.4 1; 0.4 0 0.2 1",
    repeatCount: "indefinite",
    begin: "0.1"
  })), /* @__PURE__ */ React.createElement("circle", {
    fill: "currentColor",
    stroke: "none",
    cx: 30,
    cy: 32,
    r: 6
  }, /* @__PURE__ */ React.createElement("animateTransform", {
    attributeName: "transform",
    dur: "1s",
    type: "translate",
    values: "0 15 ; 0 -10; 0 15",
    calcMode: "spline",
    keySplines: "0.8 0 0.4 1; 0.4 0 0.2 1",
    repeatCount: "indefinite",
    begin: "0.2"
  })), /* @__PURE__ */ React.createElement("circle", {
    fill: "currentColor",
    stroke: "none",
    cx: 54,
    cy: 32,
    r: 6
  }, /* @__PURE__ */ React.createElement("animateTransform", {
    attributeName: "transform",
    dur: "1s",
    type: "translate",
    values: "0 15 ; 0 -5; 0 15",
    calcMode: "spline",
    keySplines: "0.8 0 0.4 1; 0.4 0 0.2 1",
    repeatCount: "indefinite",
    begin: "0.3"
  }))), /* @__PURE__ */ React.createElement("p", {
    style: {
      fontSize: "18px",
      color: "#252336",
      textAlign: "center",
      lineHeight: "1.3",
      fontFamily: "'Inter', sans-serif",
      fontWeight: "normal"
    }
  }, "Please wait, Tina is loading data..."))), props.children);
};
const getStaticPropsForTina = async ({
  query,
  variables
}) => {
  try {
    const data = await staticRequest({ query, variables });
    return JSON.parse(JSON.stringify({
      data,
      query,
      variables
    }));
  } catch (e) {
    return JSON.parse(JSON.stringify({
      data: {},
      query,
      variables
    }));
  }
};
function is_server() {
  return !(typeof window != "undefined" && window.document);
}
const staticRequest = async ({
  query,
  variables
}) => {
  const client = new LocalClient();
  if (!is_server()) {
    console.warn(`Whoops! Looks like you are using \`staticRequest\` in the browser to fetch data.

The local server is not available outside of \`getStaticProps\` or \`getStaticPaths\` functions.
This function should only be called on the server at build time.

This will work when developing locally but NOT when deployed to production.
`);
  }
  return client.request(query, { variables });
};
function gql(strings, ...args) {
  let str = "";
  strings.forEach((string, i) => {
    str += string + (args[i] || "");
  });
  return str;
}
const Layout = ({ children }) => {
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("style", null, styles), /* @__PURE__ */ React.createElement("div", {
    className: "tina-tailwind",
    style: {
      position: "fixed",
      top: 0,
      left: 0,
      width: "100%",
      height: "100%",
      overflow: "auto",
      background: "#F6F6F9",
      fontFamily: "'Inter', sans-serif",
      zIndex: 9999
    }
  }, children));
};
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext = React.createContext && React.createContext(DefaultContext);
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function Tree2Element(tree) {
  return tree && tree.map(function(node2, i) {
    return React.createElement(node2.tag, __assign({
      key: i
    }, node2.attr), Tree2Element(node2.child));
  });
}
function GenIcon(data) {
  return function(props) {
    return React.createElement(IconBase, __assign({
      attr: __assign({}, data.attr)
    }, props), Tree2Element(data.child));
  };
}
function IconBase(props) {
  var elem = function(conf) {
    var attr = props.attr, size = props.size, title = props.title, svgProps = __rest(props, ["attr", "size", "title"]);
    var computedSize = size || conf.size || "1em";
    var className;
    if (conf.className)
      className = conf.className;
    if (props.className)
      className = (className ? className + " " : "") + props.className;
    return React.createElement("svg", __assign({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className,
      style: __assign(__assign({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && React.createElement("title", null, title), props.children);
  };
  return IconContext !== void 0 ? React.createElement(IconContext.Consumer, null, function(conf) {
    return elem(conf);
  }) : elem(DefaultContext);
}
function ImFilesEmpty(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1.1", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M14.341 5.579c-0.347-0.473-0.831-1.027-1.362-1.558s-1.085-1.015-1.558-1.362c-0.806-0.591-1.197-0.659-1.421-0.659h-5.75c-0.689 0-1.25 0.561-1.25 1.25v11.5c0 0.689 0.561 1.25 1.25 1.25h9.5c0.689 0 1.25-0.561 1.25-1.25v-7.75c0-0.224-0.068-0.615-0.659-1.421zM12.271 4.729c0.48 0.48 0.856 0.912 1.134 1.271h-2.406v-2.405c0.359 0.278 0.792 0.654 1.271 1.134v0zM14 14.75c0 0.136-0.114 0.25-0.25 0.25h-9.5c-0.136 0-0.25-0.114-0.25-0.25v-11.5c0-0.135 0.114-0.25 0.25-0.25 0 0 5.749-0 5.75 0v3.5c0 0.276 0.224 0.5 0.5 0.5h3.5v7.75z" } }, { "tag": "path", "attr": { "d": "M9.421 0.659c-0.806-0.591-1.197-0.659-1.421-0.659h-5.75c-0.689 0-1.25 0.561-1.25 1.25v11.5c0 0.604 0.43 1.109 1 1.225v-12.725c0-0.135 0.115-0.25 0.25-0.25h7.607c-0.151-0.124-0.297-0.238-0.437-0.341z" } }] })(props);
}
const useGetCollections = (cms) => {
  const api = new TinaAdminApi(cms);
  return { collections: api.fetchCollections() };
};
function IoMdClose(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M405 136.798L375.202 107 256 226.202 136.798 107 107 136.798 226.202 256 107 375.202 136.798 405 256 285.798 375.202 405 405 375.202 285.798 256z" } }] })(props);
}
function BiEdit(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "m7 17.013 4.413-.015 9.632-9.54c.378-.378.586-.88.586-1.414s-.208-1.036-.586-1.414l-1.586-1.586c-.756-.756-2.075-.752-2.825-.003L7 12.583v4.43zM18.045 4.458l1.589 1.583-1.597 1.582-1.586-1.585 1.594-1.58zM9 13.417l6.03-5.973 1.586 1.586-6.029 5.971L9 15.006v-1.589z" } }, { "tag": "path", "attr": { "d": "M5 21h14c1.103 0 2-.897 2-2v-8.668l-2 2V19H8.158c-.026 0-.053.01-.079.01-.033 0-.066-.009-.1-.01H5V5h6.847l2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2z" } }] })(props);
}
function BiLogIn(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "m13 16 5-4-5-4v3H4v2h9z" } }, { "tag": "path", "attr": { "d": "M20 3h-9c-1.103 0-2 .897-2 2v4h2V5h9v14h-9v-4H9v4c0 1.103.897 2 2 2h9c1.103 0 2-.897 2-2V5c0-1.103-.897-2-2-2z" } }] })(props);
}
function BiLogOut(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M16 13v-2H7V8l-5 4 5 4v-3z" } }, { "tag": "path", "attr": { "d": "M20 3h-9c-1.103 0-2 .897-2 2v4h2V5h9v14h-9v-4H9v4c0 1.103.897 2 2 2h9c1.103 0 2-.897 2-2V5c0-1.103-.897-2-2-2z" } }] })(props);
}
function BiMenu(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z" } }] })(props);
}
function BiPlus(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M19 11h-6V5h-2v6H5v2h6v6h2v-6h6z" } }] })(props);
}
function BiRename(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M20.005 5.995h-1v2h1v8h-1v2h1c1.103 0 2-.897 2-2v-8c0-1.102-.898-2-2-2zm-14 4H15v4H6.005z" } }, { "tag": "path", "attr": { "d": "M17.005 17.995V4H20V2h-8v2h3.005v1.995h-11c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h11V20H12v2h8v-2h-2.995v-2.005zm-13-2v-8h11v8h-11z" } }] })(props);
}
function BiSearch(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M10 18a7.952 7.952 0 0 0 4.897-1.688l4.396 4.396 1.414-1.414-4.396-4.396A7.952 7.952 0 0 0 18 10c0-4.411-3.589-8-8-8s-8 3.589-8 8 3.589 8 8 8zm0-14c3.309 0 6 2.691 6 6s-2.691 6-6 6-6-2.691-6-6 2.691-6 6-6z" } }] })(props);
}
function BiTrash(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M5 20a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V8h2V6h-4V4a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v2H3v2h2zM9 4h6v2H9zM8 8h9v12H7V8z" } }, { "tag": "path", "attr": { "d": "M9 10h2v8H9zm4 0h2v8h-2z" } }] })(props);
}
function BiX(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "m16.192 6.344-4.243 4.242-4.242-4.242-1.414 1.414L10.535 12l-4.242 4.242 1.414 1.414 4.242-4.242 4.243 4.242 1.414-1.414L13.364 12l4.242-4.242z" } }] })(props);
}
const slugify = (text) => {
  return text.toString().toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "_").replace(/^-+|-+$/g, "");
};
const Sidebar = ({ cms }) => {
  var _a, _b;
  const collectionsInfo = useGetCollections(cms);
  const screens = cms.plugins.getType("screen").all();
  const cloudConfigs = cms.plugins.getType("cloud-config").all();
  const [menuIsOpen, setMenuIsOpen] = React.useState(false);
  const isLocalMode = (_b = (_a = cms.api) == null ? void 0 : _a.tina) == null ? void 0 : _b.isLocalMode;
  const navBreakpoint = 1e3;
  const windowWidth = useWindowWidth();
  const renderDesktopNav = windowWidth > navBreakpoint;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, renderDesktopNav && /* @__PURE__ */ React.createElement(Nav, {
    isLocalMode,
    sidebarWidth: 360,
    showCollections: true,
    collectionsInfo,
    screens,
    cloudConfigs,
    contentCreators: [],
    RenderNavSite: ({ view }) => /* @__PURE__ */ React.createElement(SidebarLink, {
      label: view.name,
      to: `/screens/${slugify(view.name)}`,
      Icon: view.Icon ? view.Icon : ImFilesEmpty
    }),
    RenderNavCloud: ({ config }) => /* @__PURE__ */ React.createElement(SidebarCloudLink, {
      config
    }),
    RenderNavCollection: ({ collection }) => /* @__PURE__ */ React.createElement(SidebarLink, {
      label: collection.label ? collection.label : collection.name,
      to: `/collections/${collection.name}`,
      Icon: ImFilesEmpty
    })
  }), !renderDesktopNav && /* @__PURE__ */ React.createElement(Transition, {
    show: menuIsOpen
  }, /* @__PURE__ */ React.createElement(Transition.Child, {
    as: React.Fragment,
    enter: "transform transition-all ease-out duration-300",
    enterFrom: "opacity-0 -translate-x-full",
    enterTo: "opacity-100 translate-x-0",
    leave: "transform transition-all ease-in duration-200",
    leaveFrom: "opacity-100 translate-x-0",
    leaveTo: "opacity-0 -translate-x-full"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "fixed left-0 top-0 z-overlay h-full transform"
  }, /* @__PURE__ */ React.createElement(Nav, {
    isLocalMode,
    className: "rounded-r-md",
    sidebarWidth: 360,
    showCollections: true,
    collectionsInfo,
    screens,
    cloudConfigs,
    contentCreators: [],
    RenderNavSite: ({ view }) => /* @__PURE__ */ React.createElement(SidebarLink, {
      label: view.name,
      to: `/screens/${slugify(view.name)}`,
      Icon: view.Icon ? view.Icon : ImFilesEmpty,
      onClick: () => {
        setMenuIsOpen(false);
      }
    }),
    RenderNavCloud: ({ config }) => /* @__PURE__ */ React.createElement(SidebarCloudLink, {
      config
    }),
    RenderNavCollection: ({ collection }) => /* @__PURE__ */ React.createElement(SidebarLink, {
      label: collection.label ? collection.label : collection.name,
      to: `/collections/${collection.name}`,
      Icon: ImFilesEmpty,
      onClick: () => {
        setMenuIsOpen(false);
      }
    })
  }, /* @__PURE__ */ React.createElement("div", {
    className: "absolute top-8 right-0 transform translate-x-full overflow-hidden"
  }, /* @__PURE__ */ React.createElement(Button, {
    rounded: "right",
    variant: "secondary",
    onClick: () => {
      setMenuIsOpen(false);
    },
    className: `transition-opacity duration-150 ease-out`
  }, /* @__PURE__ */ React.createElement(IoMdClose, {
    className: "h-6 w-auto"
  })))))), /* @__PURE__ */ React.createElement(Transition.Child, {
    as: React.Fragment,
    enter: "ease-out duration-300",
    enterFrom: "opacity-0",
    enterTo: "opacity-80",
    entered: "opacity-80",
    leave: "ease-in duration-200",
    leaveFrom: "opacity-80",
    leaveTo: "opacity-0"
  }, /* @__PURE__ */ React.createElement("div", {
    onClick: () => {
      setMenuIsOpen(false);
    },
    className: "fixed z-menu inset-0 bg-gradient-to-br from-gray-800 via-gray-900 to-black"
  }))), !renderDesktopNav && /* @__PURE__ */ React.createElement(Button, {
    rounded: "right",
    variant: "secondary",
    onClick: () => {
      setMenuIsOpen(true);
    },
    className: `pointer-events-auto -ml-px absolute left-0 z-50 ${isLocalMode ? `top-10` : `top-4`}`
  }, /* @__PURE__ */ React.createElement(BiMenu, {
    className: "h-7 w-auto"
  })));
};
const SidebarLink = (props) => {
  const { to, label, Icon } = props;
  return /* @__PURE__ */ React.createElement(NavLink, {
    className: ({ isActive }) => {
      return `text-base tracking-wide ${isActive ? "text-blue-600" : "text-gray-500"} hover:text-blue-600 flex items-center opacity-90 hover:opacity-100`;
    },
    onClick: props.onClick ? props.onClick : () => {
    },
    to
  }, /* @__PURE__ */ React.createElement(Icon, {
    className: "mr-2 h-6 opacity-80 w-auto"
  }), " ", label);
};
const SidebarCloudLink = ({ config }) => {
  if (config.text) {
    return /* @__PURE__ */ React.createElement("span", {
      className: "text-base tracking-wide text-gray-500 flex items-center opacity-90"
    }, config.text, " ", /* @__PURE__ */ React.createElement("a", {
      target: "_blank",
      className: "ml-1 text-blue-600 hover:opacity-60",
      href: config.link.href
    }, config.link.text));
  }
  return /* @__PURE__ */ React.createElement("span", {
    className: "text-base tracking-wide text-gray-500 hover:text-blue-600 flex items-center opacity-90 hover:opacity-100"
  }, /* @__PURE__ */ React.createElement(config.Icon, {
    className: "mr-2 h-6 opacity-80 w-auto"
  }), /* @__PURE__ */ React.createElement("a", {
    target: "_blank",
    href: config.link.href
  }, config.link.text));
};
const GetCMS = ({ children }) => {
  try {
    const cms = useCMS();
    return /* @__PURE__ */ React.createElement(React.Fragment, null, children(cms));
  } catch (e) {
    return null;
  }
};
function MdOutlineArrowBack(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0V0z" } }, { "tag": "path", "attr": { "d": "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" } }] })(props);
}
const AuthTemplate = ({
  message,
  children
}) => {
  return /* @__PURE__ */ React.createElement("div", {
    className: "h-screen w-full bg-gradient-to-b from-blue-900 to-gray-900 flex items-center justify-center px-4 py-6"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "bg-white rounded-lg overflow-hidden shadow-lg w-full max-w-lg"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "px-5 py-4 border-b border-gray-150"
  }, /* @__PURE__ */ React.createElement("h2", {
    className: "text-2xl font-sans tracking-wide text-gray-700 flex items-center gap-0.5"
  }, /* @__PURE__ */ React.createElement("svg", {
    viewBox: "0 0 32 32",
    fill: "#EC4815",
    xmlns: "http://www.w3.org/2000/svg",
    className: "w-10 h-auto"
  }, /* @__PURE__ */ React.createElement("path", {
    d: "M18.6466 14.5553C19.9018 13.5141 20.458 7.36086 21.0014 5.14903C21.5447 2.9372 23.7919 3.04938 23.7919 3.04938C23.7919 3.04938 23.2085 4.06764 23.4464 4.82751C23.6844 5.58738 25.3145 6.26662 25.3145 6.26662L24.9629 7.19622C24.9629 7.19622 24.2288 7.10204 23.7919 7.9785C23.355 8.85496 24.3392 17.4442 24.3392 17.4442C24.3392 17.4442 21.4469 22.7275 21.4469 24.9206C21.4469 27.1136 22.4819 28.9515 22.4819 28.9515H21.0296C21.0296 28.9515 18.899 26.4086 18.462 25.1378C18.0251 23.8669 18.1998 22.596 18.1998 22.596C18.1998 22.596 15.8839 22.4646 13.8303 22.596C11.7767 22.7275 10.4072 24.498 10.16 25.4884C9.91287 26.4787 9.81048 28.9515 9.81048 28.9515H8.66211C7.96315 26.7882 7.40803 26.0129 7.70918 24.9206C8.54334 21.8949 8.37949 20.1788 8.18635 19.4145C7.99321 18.6501 6.68552 17.983 6.68552 17.983C7.32609 16.6741 7.97996 16.0452 10.7926 15.9796C13.6052 15.914 17.3915 15.5965 18.6466 14.5553Z"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M11.1268 24.7939C11.1268 24.7939 11.4236 27.5481 13.0001 28.9516H14.3511C13.0001 27.4166 12.8527 23.4155 12.8527 23.4155C12.1656 23.6399 11.3045 24.3846 11.1268 24.7939Z"
  })), /* @__PURE__ */ React.createElement("span", null, "Tina"))), message && /* @__PURE__ */ React.createElement("div", {
    className: "px-5 pt-4"
  }, /* @__PURE__ */ React.createElement("p", {
    className: "text-base font-sans leading-normal"
  }, message)), /* @__PURE__ */ React.createElement("div", {
    className: "px-5 py-4 flex gap-4 w-full justify-between"
  }, children)));
};
const LoginPage = () => {
  const { setEdit } = useEditState();
  const login = () => setEdit(true);
  return /* @__PURE__ */ React.createElement(AuthTemplate, null, /* @__PURE__ */ React.createElement("div", {
    className: "flex w-full flex-1 gap-4 items-center justify-end"
  }, /* @__PURE__ */ React.createElement(Button, {
    onClick: () => {
      window.location.href = "/";
    },
    variant: "white",
    size: "custom",
    className: "text-base h-12 px-6 flex-shrink-0 flex-grow-0"
  }, /* @__PURE__ */ React.createElement(MdOutlineArrowBack, {
    className: "w-6 h-auto mr-1.5 opacity-80"
  }), " Back To Site"), /* @__PURE__ */ React.createElement(Button, {
    onClick: () => login(),
    variant: "primary",
    size: "custom",
    className: "text-base h-12 px-6 flex-1",
    type: "submit"
  }, /* @__PURE__ */ React.createElement(BiLogIn, {
    className: "w-6 h-auto mr-2 opacity-80"
  }), " Edit With Tina")));
};
const LogoutRedirect = () => {
  const cms = useCMS();
  const { setEdit } = useEditState();
  const [searchParams] = useSearchParams();
  const slug = searchParams.get("slug") || "/";
  const logout2 = async () => {
    var _a, _b, _c, _d, _e, _f;
    if ((_b = (_a = cms == null ? void 0 : cms.api) == null ? void 0 : _a.tina) == null ? void 0 : _b.logout) {
      await cms.api.tina.logout();
      if ((_d = (_c = cms == null ? void 0 : cms.api) == null ? void 0 : _c.tina) == null ? void 0 : _d.onLogout) {
        await ((_f = (_e = cms == null ? void 0 : cms.api) == null ? void 0 : _e.tina) == null ? void 0 : _f.onLogout());
      }
    }
    setEdit(false);
  };
  useEffect(() => {
    logout2().then(() => {
      window.location.href = slug;
    });
  }, []);
  return /* @__PURE__ */ React.createElement("div", null, "Redirecting to ", slug, " ...");
};
const logout = () => {
  setEditing(false);
  window.location.href = "/";
};
const LogoutPage = () => {
  return /* @__PURE__ */ React.createElement(AuthTemplate, null, /* @__PURE__ */ React.createElement("div", {
    className: "flex w-full flex-1 gap-4 items-center justify-end"
  }, /* @__PURE__ */ React.createElement(Button, {
    onClick: () => {
      window.location.href = "/";
    },
    variant: "white",
    size: "custom",
    className: "text-base h-12 px-6 flex-shrink-0 flex-grow-0"
  }, /* @__PURE__ */ React.createElement(MdOutlineArrowBack, {
    className: "w-6 h-auto mr-1.5 opacity-80"
  }), " Back To Site"), /* @__PURE__ */ React.createElement(Button, {
    onClick: () => logout(),
    type: "submit",
    variant: "primary",
    size: "custom",
    className: "text-base h-12 px-6 flex-1"
  }, /* @__PURE__ */ React.createElement(BiLogOut, {
    className: "w-6 h-auto mr-1.5 opacity-80"
  }), " Log Out of Tina")));
};
const PageWrapper = ({
  children
}) => {
  return /* @__PURE__ */ React.createElement("div", {
    className: "relative left-0 w-full h-full bg-gradient-to-b from-gray-50/50 to-gray-50 shadow-2xl overflow-y-auto transition-opacity duration-300 ease-out flex flex-col opacity-100"
  }, children);
};
const PageHeader = ({
  isLocalMode,
  children
}) => /* @__PURE__ */ React.createElement(React.Fragment, null, isLocalMode && /* @__PURE__ */ React.createElement(LocalWarning, null), !isLocalMode && /* @__PURE__ */ React.createElement(BillingWarning, null), /* @__PURE__ */ React.createElement("div", {
  className: "pt-12 px-12"
}, /* @__PURE__ */ React.createElement("div", {
  className: "w-full mx-auto max-w-screen-xl"
}, /* @__PURE__ */ React.createElement("div", {
  className: "w-full flex justify-between items-end"
}, children))));
const PageBody = ({
  children
}) => /* @__PURE__ */ React.createElement("div", {
  className: "py-8 px-12"
}, children);
const PageBodyNarrow = ({
  children
}) => /* @__PURE__ */ React.createElement("div", {
  className: "py-10 px-12"
}, /* @__PURE__ */ React.createElement("div", {
  className: "w-full mx-auto max-w-screen-xl"
}, children));
const DashboardPage = () => {
  return /* @__PURE__ */ React.createElement(GetCMS, null, (cms) => {
    var _a, _b;
    return /* @__PURE__ */ React.createElement(PageWrapper, null, /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(PageHeader, {
      isLocalMode: (_b = (_a = cms.api) == null ? void 0 : _a.tina) == null ? void 0 : _b.isLocalMode
    }, /* @__PURE__ */ React.createElement("h3", {
      className: "text-2xl font-sans text-gray-700"
    }, "Welcome to Tina!")), /* @__PURE__ */ React.createElement(PageBodyNarrow, null, "This is your dashboard for editing or creating content. Select a collection on the left to begin.")));
  });
};
const LoadingPage = () => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
  style: {
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    zIndex: 200,
    opacity: "0.8",
    display: "flex",
    alignItems: "start",
    justifyContent: "center",
    padding: "120px 40px 40px 40px"
  }
}, /* @__PURE__ */ React.createElement("div", {
  style: {
    background: "#FFF",
    border: "1px solid #EDECF3",
    boxShadow: "0px 2px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.1)",
    borderRadius: "8px",
    padding: "32px 24px",
    width: "460px",
    maxWidth: "90%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "column"
  }
}, /* @__PURE__ */ React.createElement("svg", {
  style: {
    width: "64px",
    color: "#2296fe",
    marginTop: "-8px",
    marginBottom: "16px"
  },
  version: "1.1",
  id: "L5",
  xmlns: "http://www.w3.org/2000/svg",
  xmlnsXlink: "http://www.w3.org/1999/xlink",
  x: "0px",
  y: "0px",
  viewBox: "0 0 100 64",
  enableBackground: "new 0 0 0 0",
  xmlSpace: "preserve"
}, /* @__PURE__ */ React.createElement("circle", {
  fill: "currentColor",
  stroke: "none",
  cx: 6,
  cy: 32,
  r: 6
}, /* @__PURE__ */ React.createElement("animateTransform", {
  attributeName: "transform",
  dur: "1s",
  type: "translate",
  values: "0 15 ; 0 -15; 0 15",
  calcMode: "spline",
  keySplines: "0.8 0 0.4 1; 0.4 0 0.2 1",
  repeatCount: "indefinite",
  begin: "0.1"
})), /* @__PURE__ */ React.createElement("circle", {
  fill: "currentColor",
  stroke: "none",
  cx: 30,
  cy: 32,
  r: 6
}, /* @__PURE__ */ React.createElement("animateTransform", {
  attributeName: "transform",
  dur: "1s",
  type: "translate",
  values: "0 15 ; 0 -10; 0 15",
  calcMode: "spline",
  keySplines: "0.8 0 0.4 1; 0.4 0 0.2 1",
  repeatCount: "indefinite",
  begin: "0.2"
})), /* @__PURE__ */ React.createElement("circle", {
  fill: "currentColor",
  stroke: "none",
  cx: 54,
  cy: 32,
  r: 6
}, /* @__PURE__ */ React.createElement("animateTransform", {
  attributeName: "transform",
  dur: "1s",
  type: "translate",
  values: "0 15 ; 0 -5; 0 15",
  calcMode: "spline",
  keySplines: "0.8 0 0.4 1; 0.4 0 0.2 1",
  repeatCount: "indefinite",
  begin: "0.3"
}))), /* @__PURE__ */ React.createElement("p", {
  style: {
    fontSize: "16px",
    color: "#716c7f",
    textAlign: "center",
    lineHeight: "1.3",
    fontFamily: "'Inter', sans-serif",
    fontWeight: "normal"
  }
}, "Please wait, Tina is loading data..."))));
const useGetCollection = (cms, collectionName, includeDocuments = true, after = "", sortKey, filterArgs) => {
  const api = new TinaAdminApi(cms);
  const schema = cms.api.tina.schema;
  const collectionExtra = schema.getCollection(collectionName);
  const [collection, setCollection] = useState(void 0);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(void 0);
  const [resetState, setResetSate] = useState(0);
  useEffect(() => {
    const fetchCollection = async () => {
      var _a;
      if (await api.isAuthenticated()) {
        const { name, order } = JSON.parse(sortKey || "{}");
        const validSortKey = ((_a = collectionExtra.fields) == null ? void 0 : _a.map((x) => x.name).includes(name)) ? name : void 0;
        try {
          const collection2 = await api.fetchCollection(collectionName, includeDocuments, after, validSortKey, order, filterArgs);
          setCollection(collection2);
        } catch (error2) {
          cms.alerts.error(`[${error2.name}] GetCollection failed: ${error2.message}`);
          console.error(error2);
          setCollection(void 0);
          setError(error2);
        }
        setLoading(false);
      }
    };
    setLoading(true);
    fetchCollection();
  }, [cms, collectionName, resetState, after, sortKey]);
  const reFetchCollection = () => setResetSate((x) => x + 1);
  return { collection, loading, error, reFetchCollection, collectionExtra };
};
const GetCollection = ({
  cms,
  collectionName,
  includeDocuments = true,
  startCursor,
  sortKey,
  children,
  filterArgs
}) => {
  const { collection, loading, error, reFetchCollection, collectionExtra } = useGetCollection(cms, collectionName, includeDocuments, startCursor || "", sortKey, filterArgs) || {};
  if (error) {
    return null;
  }
  if (loading) {
    return /* @__PURE__ */ React.createElement(LoadingPage, null);
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, children(collection, loading, reFetchCollection, collectionExtra));
};
const LOCAL_STORAGE_KEY = "tinacms.admin.collection.list.page";
const isSSR = typeof window === "undefined";
const TemplateMenu = ({ templates }) => {
  return /* @__PURE__ */ React.createElement(Menu, {
    as: "div",
    className: "relative inline-block text-left"
  }, () => /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(Menu.Button, {
    className: "icon-parent inline-flex items-center font-medium focus:outline-none focus:ring-2 focus:shadow-outline text-center rounded-full justify-center transition-all duration-150 ease-out  shadow text-white bg-blue-500 hover:bg-blue-600 focus:ring-blue-500 text-sm h-10 px-6"
  }, "Create New ", /* @__PURE__ */ React.createElement(BiPlus, {
    className: "w-5 h-full ml-1 opacity-70"
  }))), /* @__PURE__ */ React.createElement(Transition, {
    as: Fragment,
    enter: "transition ease-out duration-100",
    enterFrom: "transform opacity-0 scale-95",
    enterTo: "transform opacity-100 scale-100",
    leave: "transition ease-in duration-75",
    leaveFrom: "transform opacity-100 scale-100",
    leaveTo: "transform opacity-0 scale-95"
  }, /* @__PURE__ */ React.createElement(Menu.Items, {
    className: "origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "py-1"
  }, templates.map((template) => /* @__PURE__ */ React.createElement(Menu.Item, {
    key: `${template.label}-${template.name}`
  }, ({ active }) => /* @__PURE__ */ React.createElement(Link, {
    to: `${template.name}/new`,
    className: `w-full text-md px-4 py-2 tracking-wide flex items-center opacity-80 text-gray-600 ${active && "text-gray-800 opacity-100"}`
  }, template.label))))))));
};
const handleNavigate = (navigate, cms, collection, collectionDefinition, document) => {
  var _a, _b;
  const plugins = cms.plugins.all("tina-admin");
  const routeMapping = plugins.find(({ name }) => name === "route-mapping");
  const tinaPreview = cms.flags.get("tina-preview") || false;
  let routeOverride = ((_a = collectionDefinition.ui) == null ? void 0 : _a.router) ? (_b = collectionDefinition.ui) == null ? void 0 : _b.router({
    document,
    collection: collectionDefinition
  }) : routeMapping ? routeMapping.mapper(collection, document) : void 0;
  if (routeOverride) {
    if (routeOverride.startsWith("/")) {
      routeOverride = routeOverride.slice(1);
    }
    tinaPreview ? navigate(`/~/${routeOverride}`) : window.location.href = routeOverride;
    return null;
  } else {
    navigate(document._sys.breadcrumbs.join("/"));
  }
};
const CollectionListPage = () => {
  const navigate = useNavigate();
  const { collectionName } = useParams();
  const [deleteModalOpen, setDeleteModalOpen] = React.useState(false);
  const [renameModalOpen, setRenameModalOpen] = React.useState(false);
  const [vars, setVars] = React.useState({
    collection: collectionName,
    relativePath: "",
    newRelativePath: "",
    filterField: "",
    startsWith: "",
    endsWith: "",
    before: "",
    after: "",
    booleanEquals: null
  });
  const [endCursor, setEndCursor] = useState("");
  const [prevCursors, setPrevCursors] = useState([]);
  const [sortKey, setSortKey] = useState(isSSR ? "" : window.localStorage.getItem(`${LOCAL_STORAGE_KEY}.${collectionName}`) || JSON.stringify({
    order: "asc",
    name: ""
  }));
  const [sortOrder, setSortOrder] = useState("asc");
  const loc = useLocation();
  useEffect(() => {
    setSortKey(window.localStorage.getItem(`${LOCAL_STORAGE_KEY}.${collectionName}`) || JSON.stringify({
      order: "asc",
      name: ""
    }));
    setEndCursor("");
    setPrevCursors([]);
  }, [loc]);
  useEffect(() => {
    setVars((old) => ({
      ...old,
      collection: collectionName,
      relativePath: "",
      newRelativePath: "",
      filterField: "",
      startsWith: "",
      endsWith: "",
      before: "",
      after: "",
      booleanEquals: null
    }));
  }, [collectionName]);
  return /* @__PURE__ */ React.createElement(GetCMS, null, (cms) => {
    return /* @__PURE__ */ React.createElement(GetCollection, {
      cms,
      collectionName,
      includeDocuments: true,
      startCursor: endCursor,
      sortKey,
      filterArgs: collectionName === vars.collection ? vars : {
        collection: collectionName,
        relativePath: "",
        newRelativePath: "",
        filterField: "",
        startsWith: "",
        endsWith: "",
        before: "",
        after: "",
        booleanEquals: null
      }
    }, (collection, _loading, reFetchCollection, collectionExtra) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      const totalCount = collection.documents.totalCount;
      const documents = collection.documents.edges;
      const admin = cms.api.admin;
      const pageInfo = collection.documents.pageInfo;
      const fields = (_a = collectionExtra.fields) == null ? void 0 : _a.filter((x) => ["string", "number", "datetime", "boolean"].includes(x.type));
      const filterFields = (_b = collectionExtra.fields) == null ? void 0 : _b.filter((x) => {
        return ["string", "datetime", "boolean"].includes(x.type) && !x.list;
      });
      const filterField = filterFields == null ? void 0 : filterFields.find((x) => x.name === vars.filterField);
      const showStartsWith = (filterField == null ? void 0 : filterField.type) === "string" && !filterField.list;
      const showDateFilter = (filterField == null ? void 0 : filterField.type) === "datetime";
      const showBooleanToggle = (filterField == null ? void 0 : filterField.type) === "boolean" && !filterField.list;
      const collectionDefinition = cms.api.tina.schema.getCollection(collection.name);
      const allowCreate = (_e = (_d = (_c = collectionDefinition == null ? void 0 : collectionDefinition.ui) == null ? void 0 : _c.allowedActions) == null ? void 0 : _d.create) != null ? _e : true;
      const allowDelete = (_h = (_g = (_f = collectionDefinition == null ? void 0 : collectionDefinition.ui) == null ? void 0 : _f.allowedActions) == null ? void 0 : _g.delete) != null ? _h : true;
      return /* @__PURE__ */ React.createElement(PageWrapper, null, /* @__PURE__ */ React.createElement(React.Fragment, null, deleteModalOpen && /* @__PURE__ */ React.createElement(DeleteModal, {
        filename: vars.relativePath,
        deleteFunc: async () => {
          try {
            await admin.deleteDocument(vars);
            cms.alerts.info("Document was successfully deleted");
            reFetchCollection();
          } catch (error) {
            cms.alerts.warn("Document was not deleted, ask a developer for help or check the console for an error message");
            console.error(error);
            throw error;
          }
        },
        close: () => setDeleteModalOpen(false)
      }), renameModalOpen && /* @__PURE__ */ React.createElement(RenameModal, {
        filename: vars.relativePath,
        newRelativePath: vars.newRelativePath,
        setNewRelativePath: (newRelativePath) => {
          setVars((vars2) => {
            return { ...vars2, newRelativePath };
          });
        },
        renameFunc: async () => {
          const newRelativePath = `${vars.newRelativePath}.${collection.format}`;
          try {
            await admin.renameDocument({
              collection: vars.collection,
              relativePath: vars.relativePath,
              newRelativePath
            });
            cms.alerts.info("Document was successfully renamed");
            reFetchCollection();
          } catch (error) {
            cms.alerts.warn("Document was not renamed, ask a developer for help or check the console for an error message");
            console.error(error);
            throw error;
          }
        },
        close: () => setRenameModalOpen(false)
      }), /* @__PURE__ */ React.createElement(PageHeader, {
        isLocalMode: (_j = (_i = cms == null ? void 0 : cms.api) == null ? void 0 : _i.tina) == null ? void 0 : _j.isLocalMode
      }, /* @__PURE__ */ React.createElement("div", {
        className: "w-full grid grid-flow-col items-end gap-4"
      }, /* @__PURE__ */ React.createElement("div", {
        className: "flex flex-col gap-4"
      }, /* @__PURE__ */ React.createElement("h3", {
        className: "font-sans text-2xl text-gray-700"
      }, collection.label ? collection.label : collection.name), (fields == null ? void 0 : fields.length) > 0 && /* @__PURE__ */ React.createElement("div", {
        className: "flex gap-4 items-end flex-wrap"
      }, /* @__PURE__ */ React.createElement("div", {
        className: "flex flex-col gap-2 items-start"
      }, /* @__PURE__ */ React.createElement("label", {
        htmlFor: "sort",
        className: "block font-sans text-xs font-semibold text-gray-500 whitespace-normal"
      }, "Sort by"), /* @__PURE__ */ React.createElement(Select, {
        name: "sort",
        options: [
          {
            label: "Default",
            value: JSON.stringify({
              order: "asc",
              name: ""
            })
          },
          ...fields.map((x) => [
            {
              label: (x.label || x.name) + (x.type === "datetime" ? " (Oldest First)" : " (Ascending)"),
              value: JSON.stringify({
                name: x.name,
                order: "asc"
              })
            },
            {
              label: (x.label || x.name) + (x.type === "datetime" ? " (Newest First)" : " (Descending)"),
              value: JSON.stringify({
                name: x.name,
                order: "desc"
              })
            }
          ]).flat()
        ],
        input: {
          id: "sort",
          name: "sort",
          value: sortKey,
          onChange: (e) => {
            const val = JSON.parse(e.target.value);
            setEndCursor("");
            setPrevCursors([]);
            window == null ? void 0 : window.localStorage.setItem(`${LOCAL_STORAGE_KEY}.${collectionName}`, e.target.value);
            setSortKey(e.target.value);
            setSortOrder(val.order);
          }
        }
      })), /* @__PURE__ */ React.createElement("div", {
        className: "flex flex-wrap gap-4 items-end"
      }, /* @__PURE__ */ React.createElement("div", {
        className: "flex flex-shrink-0 flex-col gap-2 items-start"
      }, /* @__PURE__ */ React.createElement("label", {
        htmlFor: "filter",
        className: "block font-sans text-xs font-semibold text-gray-500 whitespace-normal"
      }, "Filter by"), /* @__PURE__ */ React.createElement(Select, {
        name: "filter",
        options: [
          {
            label: "None",
            value: ""
          },
          ...filterFields.map((x) => ({
            label: x.label || x.name,
            value: x.name
          }))
        ],
        input: {
          id: "filter",
          name: "filter",
          value: vars.filterField,
          onChange: (e) => {
            const val = e.target.value;
            setEndCursor("");
            setPrevCursors([]);
            setVars((old) => ({
              ...old,
              filterField: val
            }));
          }
        }
      })), showStartsWith && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
        className: "flex flex-shrink-0 flex-col gap-2 items-start"
      }, /* @__PURE__ */ React.createElement("label", {
        htmlFor: "startsWith",
        className: "block font-sans text-xs font-semibold text-gray-500 whitespace-normal"
      }, "Starts with"), /* @__PURE__ */ React.createElement(Input, {
        name: "startsWith",
        id: "startsWith",
        value: vars.startsWith,
        onChange: (e) => {
          const val = e.target.value;
          setVars((old) => ({
            ...old,
            startsWith: val,
            after: "",
            before: "",
            booleanEquals: null
          }));
        }
      }))), showDateFilter && /* @__PURE__ */ React.createElement("div", {
        className: "flex flex-shrink-0 gap-4"
      }, /* @__PURE__ */ React.createElement("div", {
        className: "flex flex-col gap-2 items-start"
      }, /* @__PURE__ */ React.createElement("label", {
        htmlFor: "dateAfter",
        className: "block font-sans text-xs font-semibold text-gray-500 whitespace-normal"
      }, "After"), /* @__PURE__ */ React.createElement(ReactDateTimeWithStyles, {
        inputProps: {
          className: textFieldClasses
        },
        value: vars.after,
        onChange: (e) => {
          setVars((old) => ({
            ...old,
            after: e.format(),
            booleanEquals: null,
            startsWith: ""
          }));
        }
      })), /* @__PURE__ */ React.createElement("div", {
        className: "flex flex-col gap-2 items-start"
      }, /* @__PURE__ */ React.createElement("label", {
        htmlFor: "dateBefore",
        className: "block font-sans text-xs font-semibold text-gray-500 whitespace-normal"
      }, "Before"), /* @__PURE__ */ React.createElement(ReactDateTimeWithStyles, {
        inputProps: {
          className: textFieldClasses
        },
        value: vars.before,
        onChange: (e) => {
          setVars((old) => ({
            ...old,
            before: e.format(),
            booleanEquals: null,
            startsWith: ""
          }));
        }
      }))), showBooleanToggle && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
        className: "flex flex-col gap-2 items-start"
      }, /* @__PURE__ */ React.createElement("label", {
        htmlFor: "toggle",
        className: "block font-sans text-xs font-semibold text-gray-500 whitespace-normal"
      }, filterField.label || filterField.name), /* @__PURE__ */ React.createElement(Toggle, {
        field: filterField,
        input: {
          name: "toggle",
          value: (_k = vars.booleanEquals) != null ? _k : false,
          onChange: () => {
            setVars((old) => ({
              ...old,
              booleanEquals: !old.booleanEquals,
              after: "",
              before: "",
              startsWith: ""
            }));
          }
        },
        name: "toggle"
      }))), (showStartsWith || showDateFilter || showBooleanToggle) && /* @__PURE__ */ React.createElement("div", {
        className: "flex gap-3"
      }, /* @__PURE__ */ React.createElement(Button, {
        onClick: () => {
          setEndCursor("");
          setPrevCursors([]);
          reFetchCollection();
        },
        variant: "primary"
      }, "Search", " ", /* @__PURE__ */ React.createElement(BiSearch, {
        className: "w-5 h-full ml-1.5 opacity-70"
      })), (vars.startsWith || vars.after || vars.before || vars.booleanEquals) && /* @__PURE__ */ React.createElement(Button, {
        onClick: () => {
          setVars((old) => ({
            ...old,
            startsWith: "",
            after: "",
            before: "",
            booleanEquals: null
          }));
          setEndCursor("");
          setPrevCursors([]);
          reFetchCollection();
        },
        variant: "white"
      }, "Clear", " ", /* @__PURE__ */ React.createElement(BiX, {
        className: "w-5 h-full ml-1 opacity-70"
      })))))), /* @__PURE__ */ React.createElement("div", {
        className: "flex self-end	justify-self-end"
      }, !collection.templates && allowCreate && /* @__PURE__ */ React.createElement(Link, {
        to: `new`,
        className: "icon-parent inline-flex items-center font-medium focus:outline-none focus:ring-2 focus:shadow-outline text-center rounded-full justify-center transition-all duration-150 ease-out whitespace-nowrap shadow text-white bg-blue-500 hover:bg-blue-600 focus:ring-blue-500 text-sm h-10 px-6"
      }, "Create New", " ", /* @__PURE__ */ React.createElement(BiPlus, {
        className: "w-5 h-full ml-1 opacity-70"
      })), collection.templates && allowCreate && /* @__PURE__ */ React.createElement(TemplateMenu, {
        templates: collection.templates
      })))), /* @__PURE__ */ React.createElement(PageBody, null, /* @__PURE__ */ React.createElement("div", {
        className: "w-full mx-auto max-w-screen-xl"
      }, totalCount > 0 && /* @__PURE__ */ React.createElement("table", {
        className: "table-auto shadow bg-white border-b border-gray-200 w-full max-w-full rounded-lg"
      }, /* @__PURE__ */ React.createElement("tbody", {
        className: "divide-y divide-gray-150"
      }, documents.map((document) => {
        var _a2;
        const hasTitle = Boolean(document.node._sys.title);
        const subfolders = document.node._sys.breadcrumbs.slice(0, -1).join("/");
        return /* @__PURE__ */ React.createElement("tr", {
          key: `document-${document.node._sys.relativePath}`,
          className: ""
        }, /* @__PURE__ */ React.createElement("td", {
          className: "pl-5 pr-3 py-2 truncate max-w-0"
        }, /* @__PURE__ */ React.createElement("a", {
          className: "text-blue-600 hover:text-blue-400 flex items-center gap-3 cursor-pointer truncate",
          onClick: () => {
            handleNavigate(navigate, cms, collection, collectionDefinition, document.node);
          }
        }, /* @__PURE__ */ React.createElement(BiEdit, {
          className: "inline-block h-6 w-auto flex-shrink-0 opacity-70"
        }), /* @__PURE__ */ React.createElement("span", {
          className: "truncate block"
        }, /* @__PURE__ */ React.createElement("span", {
          className: "block text-xs text-gray-400 mb-1 uppercase"
        }, hasTitle ? "Title" : "Filename"), /* @__PURE__ */ React.createElement("span", {
          className: "h-5 leading-5 block truncate"
        }, !hasTitle && subfolders && /* @__PURE__ */ React.createElement("span", {
          className: "text-xs text-gray-400"
        }, `${subfolders}/`), /* @__PURE__ */ React.createElement("span", null, hasTitle ? (_a2 = document.node._sys) == null ? void 0 : _a2.title : document.node._sys.filename))))), hasTitle && /* @__PURE__ */ React.createElement("td", {
          className: "px-3 py-4 truncate max-w-0 "
        }, /* @__PURE__ */ React.createElement("span", {
          className: "block text-xs text-gray-400 mb-1 uppercase"
        }, "Filename"), /* @__PURE__ */ React.createElement("span", {
          className: "h-5 leading-5 block text-sm font-medium text-gray-900 truncate"
        }, subfolders && /* @__PURE__ */ React.createElement("span", {
          className: "text-xs text-gray-400"
        }, `${subfolders}/`), /* @__PURE__ */ React.createElement("span", null, document.node._sys.filename))), /* @__PURE__ */ React.createElement("td", {
          className: "px-3 py-4 truncate w-[15%]"
        }, /* @__PURE__ */ React.createElement("span", {
          className: "block text-xs text-gray-400 mb-1 uppercase"
        }, "Extension"), /* @__PURE__ */ React.createElement("span", {
          className: "h-5 leading-5 block text-sm font-medium text-gray-900"
        }, document.node._sys.extension)), /* @__PURE__ */ React.createElement("td", {
          className: "px-3 py-4 truncate w-[15%]"
        }, /* @__PURE__ */ React.createElement("span", {
          className: "block text-xs text-gray-400 mb-1 uppercase"
        }, "Template"), /* @__PURE__ */ React.createElement("span", {
          className: "h-5 leading-5 block text-sm font-medium text-gray-900"
        }, document.node._sys.template)), /* @__PURE__ */ React.createElement("td", {
          className: "w-0"
        }, /* @__PURE__ */ React.createElement(OverflowMenu, {
          toolbarItems: [
            {
              name: "edit",
              label: "Edit in Admin",
              Icon: /* @__PURE__ */ React.createElement(BiEdit, {
                size: "1.3rem"
              }),
              onMouseDown: () => {
                navigate(`${document.node._sys.breadcrumbs.join("/")}`, { replace: true });
              }
            },
            allowDelete && {
              name: "delete",
              label: "Delete",
              Icon: /* @__PURE__ */ React.createElement(BiTrash, {
                size: "1.3rem",
                className: "text-red-500"
              }),
              onMouseDown: () => {
                setVars((old) => ({
                  ...old,
                  collection: collectionName,
                  relativePath: document.node._sys.breadcrumbs.join("/") + document.node._sys.extension,
                  newRelativePath: ""
                }));
                setDeleteModalOpen(true);
              }
            },
            allowDelete && {
              name: "rename",
              label: "Rename",
              Icon: /* @__PURE__ */ React.createElement(BiRename, {
                size: "1.3rem",
                className: "text-red-500"
              }),
              onMouseDown: () => {
                setVars((old) => ({
                  ...old,
                  collection: collectionName,
                  relativePath: document.node._sys.breadcrumbs.join("/") + document.node._sys.extension,
                  newRelativePath: ""
                }));
                setRenameModalOpen(true);
              }
            }
          ].filter(Boolean)
        })));
      }))), /* @__PURE__ */ React.createElement("div", {
        className: "pt-4"
      }, /* @__PURE__ */ React.createElement(CursorPaginator, {
        variant: "white",
        hasNext: sortOrder === "asc" ? pageInfo == null ? void 0 : pageInfo.hasNextPage : pageInfo.hasPreviousPage,
        navigateNext: () => {
          const newState = [...prevCursors, endCursor];
          setPrevCursors(newState);
          setEndCursor(pageInfo == null ? void 0 : pageInfo.endCursor);
        },
        hasPrev: prevCursors.length > 0,
        navigatePrev: () => {
          const prev = prevCursors[prevCursors.length - 1];
          if (typeof prev === "string") {
            const newState = prevCursors.slice(0, -1);
            setPrevCursors(newState);
            setEndCursor(prev);
          }
        }
      }))))));
    });
  });
};
const DeleteModal = ({ close: close2, deleteFunc, filename }) => {
  return /* @__PURE__ */ React.createElement(Modal, null, /* @__PURE__ */ React.createElement(PopupModal, null, /* @__PURE__ */ React.createElement(ModalHeader, {
    close: close2
  }, "Delete ", filename), /* @__PURE__ */ React.createElement(ModalBody, {
    padded: true
  }, /* @__PURE__ */ React.createElement("p", null, `Are you sure you want to delete ${filename}?`)), /* @__PURE__ */ React.createElement(ModalActions, null, /* @__PURE__ */ React.createElement(Button, {
    style: { flexGrow: 2 },
    onClick: close2
  }, "Cancel"), /* @__PURE__ */ React.createElement(Button, {
    style: { flexGrow: 3 },
    variant: "danger",
    onClick: async () => {
      await deleteFunc();
      close2();
    }
  }, "Delete"))));
};
const RenameModal = ({
  close: close2,
  renameFunc,
  filename,
  newRelativePath,
  setNewRelativePath
}) => {
  return /* @__PURE__ */ React.createElement(Modal, null, /* @__PURE__ */ React.createElement(PopupModal, null, /* @__PURE__ */ React.createElement(ModalHeader, {
    close: close2
  }, "Rename ", filename), /* @__PURE__ */ React.createElement(ModalBody, {
    padded: true
  }, /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("p", {
    className: "mb-4"
  }, "Are you sure you want to rename ", /* @__PURE__ */ React.createElement("strong", null, filename), "? TinaCMS uses the filename as the ID; renaming this file could result in unresolved references."), /* @__PURE__ */ React.createElement(BaseTextField, {
    placeholder: "Enter a new name for the document's file",
    value: newRelativePath,
    onChange: (event) => setNewRelativePath(event.target.value)
  }))), /* @__PURE__ */ React.createElement(ModalActions, null, /* @__PURE__ */ React.createElement(Button, {
    style: { flexGrow: 2 },
    onClick: close2
  }, "Cancel"), /* @__PURE__ */ React.createElement(Button, {
    style: { flexGrow: 3 },
    variant: "primary",
    onClick: async () => {
      await renameFunc();
      close2();
    }
  }, "Rename"))));
};
function HiChevronRight(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 20 20", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "d": "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z", "clipRule": "evenodd" } }] })(props);
}
function FaLock(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 448 512" }, "child": [{ "tag": "path", "attr": { "d": "M400 224h-24v-72C376 68.2 307.8 0 224 0S72 68.2 72 152v72H48c-26.5 0-48 21.5-48 48v192c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V272c0-26.5-21.5-48-48-48zm-104 0H152v-72c0-39.7 32.3-72 72-72s72 32.3 72 72v72z" } }] })(props);
}
function FaUnlock(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 448 512" }, "child": [{ "tag": "path", "attr": { "d": "M400 256H152V152.9c0-39.6 31.7-72.5 71.3-72.9 40-.4 72.7 32.1 72.7 72v16c0 13.3 10.7 24 24 24h32c13.3 0 24-10.7 24-24v-16C376 68 307.5-.3 223.5 0 139.5.3 72 69.5 72 153.5V256H48c-26.5 0-48 21.5-48 48v160c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V304c0-26.5-21.5-48-48-48z" } }] })(props);
}
const createDocument = async (cms, collection, template, mutationInfo, values) => {
  const api = new TinaAdminApi(cms);
  const { filename, ...leftover } = values;
  const { includeCollection, includeTemplate } = mutationInfo;
  const relativePath = `${filename}.${collection.format}`;
  const params = transformDocumentIntoMutationRequestPayload({
    _collection: collection.name,
    ...template && { _template: template.name },
    ...leftover
  }, {
    includeCollection,
    includeTemplate
  });
  if (await api.isAuthenticated()) {
    await api.createDocument(collection.name, relativePath, params);
  } else {
    const authMessage = `CreateDocument failed: User is no longer authenticated; please login and try again.`;
    cms.alerts.error(authMessage);
    console.error(authMessage);
    return false;
  }
};
const CollectionCreatePage = () => {
  const { collectionName, templateName } = useParams();
  return /* @__PURE__ */ React.createElement(GetCMS, null, (cms) => /* @__PURE__ */ React.createElement(GetCollection, {
    cms,
    collectionName,
    includeDocuments: false
  }, (collection) => {
    const mutationInfo = {
      includeCollection: true,
      includeTemplate: !!collection.templates
    };
    return /* @__PURE__ */ React.createElement(RenderForm$1, {
      cms,
      collection,
      templateName,
      mutationInfo
    });
  }));
};
const FilenameInput = (props) => {
  const [filenameTouched, setFilenameTouched] = React.useState(false);
  return /* @__PURE__ */ React.createElement("div", {
    className: "group relative block cursor-pointer",
    onClick: () => {
      setFilenameTouched(true);
    }
  }, /* @__PURE__ */ React.createElement("input", {
    type: "text",
    className: `shadow-inner focus:shadow-outline focus:border-blue-500 focus:outline-none block text-base pr-3 truncate py-2 w-full border transition-all ease-out duration-150 focus:text-gray-900 rounded-md ${props.readonly || !filenameTouched ? "bg-gray-50 text-gray-300  border-gray-150 pointer-events-none pl-8 group-hover:bg-white group-hover:text-gray-600  group-hover:border-gray-200" : "bg-white text-gray-600  border-gray-200 pl-3"}`,
    ...props,
    disabled: props.readonly || !filenameTouched
  }), /* @__PURE__ */ React.createElement(FaLock, {
    className: `text-gray-400 absolute top-1/2 left-2 -translate-y-1/2 pointer-events-none h-5 w-auto transition-opacity duration-150 ease-out ${!filenameTouched && !props.readonly ? "opacity-20 group-hover:opacity-0 group-active:opacity-0" : "opacity-0"}`
  }), /* @__PURE__ */ React.createElement(FaUnlock, {
    className: `text-blue-500 absolute top-1/2 left-2 -translate-y-1/2 pointer-events-none h-5 w-auto transition-opacity duration-150 ease-out ${!filenameTouched && !props.readonly ? "opacity-0 group-hover:opacity-80 group-active:opacity-80" : "opacity-0"}`
  }));
};
const RenderForm$1 = ({ cms, collection, templateName, mutationInfo }) => {
  var _a, _b, _c, _d, _e, _f;
  const navigate = useNavigate();
  const [formIsPristine, setFormIsPristine] = useState(true);
  const schema = cms.api.tina.schema;
  const schemaCollection = schema.getCollection(collection.name);
  const template = schema.getTemplateForData({
    collection: schemaCollection,
    data: { _template: templateName }
  });
  const formInfo = resolveForm({
    collection: schemaCollection,
    basename: schemaCollection.name,
    schema,
    template
  });
  let slugFunction = (_b = (_a = template == null ? void 0 : template.ui) == null ? void 0 : _a.filename) == null ? void 0 : _b.slugify;
  if (!slugFunction) {
    const titleField = (_c = template == null ? void 0 : template.fields.find((x) => x.required && x.type === "string" && x.isTitle)) == null ? void 0 : _c.name;
    if (titleField) {
      slugFunction = (values) => {
        var _a2;
        return (_a2 = values[titleField]) == null ? void 0 : _a2.replace(/ /g, "-").replace(/[^a-zA-Z0-9-]/g, "");
      };
    }
  }
  const defaultItem = ((_d = template.ui) == null ? void 0 : _d.defaultItem) || (template == null ? void 0 : template.defaultItem);
  const form = useMemo(() => {
    var _a2, _b2;
    return new Form({
      initialValues: typeof defaultItem === "function" ? defaultItem() : defaultItem,
      extraSubscribeValues: { active: true, submitting: true, touched: true },
      onChange: (values) => {
        var _a3;
        if (slugFunction && (values == null ? void 0 : values.active) !== "filename" && !(values == null ? void 0 : values.submitting) && !((_a3 = values.touched) == null ? void 0 : _a3.filename)) {
          const value = slugFunction(values == null ? void 0 : values.values);
          form.finalForm.change("filename", value);
        }
      },
      id: "create-form",
      label: "form",
      fields: [
        ...formInfo.fields,
        {
          name: "filename",
          label: "Filename",
          component: slugFunction ? wrapFieldsWithMeta(({ field, input, meta }) => {
            var _a3, _b3;
            return /* @__PURE__ */ React.createElement(FilenameInput, {
              readonly: (_b3 = (_a3 = template == null ? void 0 : template.ui) == null ? void 0 : _a3.filename) == null ? void 0 : _b3.readonly,
              ...input
            });
          }) : "text",
          disabled: (_b2 = (_a2 = template == null ? void 0 : template.ui) == null ? void 0 : _a2.filename) == null ? void 0 : _b2.readonly,
          description: /* @__PURE__ */ React.createElement("span", null, "A unique filename for the content.", /* @__PURE__ */ React.createElement("br", null), "Examples: ", /* @__PURE__ */ React.createElement("code", null, "My_Document"), ", ", /* @__PURE__ */ React.createElement("code", null, "My_Document.en"), ",", " ", /* @__PURE__ */ React.createElement("code", null, "sub-folder/My_Document")),
          placeholder: `My_Document`,
          validate: (value, allValues, meta) => {
            if (!value) {
              if (meta.dirty) {
                return "Required";
              }
              return true;
            }
            const isValid = /^[_a-zA-Z0-9][\.\-_\/a-zA-Z0-9]*$/.test(value);
            if (value && !isValid) {
              return "Must begin with a-z, A-Z, 0-9, or _ and contain only a-z, A-Z, 0-9, -, _, ., or /.";
            }
          }
        }
      ],
      onSubmit: async (values) => {
        try {
          await createDocument(cms, collection, template, mutationInfo, values);
          cms.alerts.success("Document created!");
          navigate(`/collections/${collection.name}`);
        } catch (error) {
          console.error(error);
          const defaultErrorText = "There was a problem saving your document.";
          if (error.message.includes("already exists")) {
            cms.alerts.error(`${defaultErrorText} The "Filename" is alredy used for another document, please modify it.`);
          } else {
            cms.alerts.error(defaultErrorText);
          }
          throw new Error(`[${error.name}] CreateDocument failed: ${error.message}`);
        }
      }
    });
  }, [cms, collection, mutationInfo]);
  const navBreakpoint = 1e3;
  const windowWidth = useWindowWidth();
  const renderNavToggle = windowWidth < navBreakpoint + 1;
  const headerPadding = renderNavToggle ? "px-20" : "px-6";
  return /* @__PURE__ */ React.createElement(PageWrapper, null, /* @__PURE__ */ React.createElement(React.Fragment, null, ((_f = (_e = cms == null ? void 0 : cms.api) == null ? void 0 : _e.tina) == null ? void 0 : _f.isLocalMode) ? /* @__PURE__ */ React.createElement(LocalWarning, null) : /* @__PURE__ */ React.createElement(BillingWarning, null), /* @__PURE__ */ React.createElement("div", {
    className: `py-4 border-b border-gray-200 bg-white ${headerPadding}`
  }, /* @__PURE__ */ React.createElement("div", {
    className: "max-w-form mx-auto"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "mb-2"
  }, /* @__PURE__ */ React.createElement("span", {
    className: "block text-sm leading-tight uppercase text-gray-400 mb-1"
  }, /* @__PURE__ */ React.createElement(Link, {
    to: `/collections/${collection.name}`,
    className: "inline-block text-current hover:text-blue-400 focus:underline focus:outline-none focus:text-blue-400 font-medium transition-colors duration-150 ease-out"
  }, collection.label ? collection.label : collection.name), /* @__PURE__ */ React.createElement(HiChevronRight, {
    className: "inline-block -mt-0.5 opacity-50"
  })), /* @__PURE__ */ React.createElement("span", {
    className: "text-xl text-gray-700 font-medium leading-tight"
  }, "Create New")), /* @__PURE__ */ React.createElement(FormStatus, {
    pristine: formIsPristine
  }))), /* @__PURE__ */ React.createElement(FormBuilder, {
    form,
    onPristineChange: setFormIsPristine
  })));
};
const useGetDocument = (cms, collectionName, relativePath) => {
  const api = new TinaAdminApi(cms);
  const [document, setDocument] = useState(void 0);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(void 0);
  useEffect(() => {
    const fetchDocument = async () => {
      if (api.isAuthenticated()) {
        try {
          const response = await api.fetchDocument(collectionName, relativePath);
          setDocument(response.document);
        } catch (error2) {
          cms.alerts.error(`[${error2.name}] GetDocument failed: ${error2.message}`);
          console.error(error2);
          setDocument(void 0);
          setError(error2);
        }
        setLoading(false);
      }
    };
    setLoading(true);
    fetchDocument();
  }, [cms, collectionName, relativePath]);
  return { document, loading, error };
};
const GetDocument = ({
  cms,
  collectionName,
  relativePath,
  children
}) => {
  const { document, loading, error } = useGetDocument(cms, collectionName, relativePath);
  if (error) {
    return null;
  }
  if (loading) {
    return /* @__PURE__ */ React.createElement(LoadingPage, null);
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, children(document, loading));
};
const updateDocument = async (cms, relativePath, collection, mutationInfo, values) => {
  const api = new TinaAdminApi(cms);
  const { includeCollection, includeTemplate } = mutationInfo;
  const params = transformDocumentIntoMutationRequestPayload(values, {
    includeCollection,
    includeTemplate
  });
  if (await api.isAuthenticated()) {
    await api.updateDocument(collection.name, relativePath, params);
  } else {
    const authMessage = `UpdateDocument failed: User is no longer authenticated; please login and try again.`;
    cms.alerts.error(authMessage);
    console.error(authMessage);
    return false;
  }
};
const CollectionUpdatePage = () => {
  const { collectionName, ...rest } = useParams();
  const { "*": filename } = rest;
  return /* @__PURE__ */ React.createElement(GetCMS, null, (cms) => /* @__PURE__ */ React.createElement(GetCollection, {
    cms,
    collectionName,
    includeDocuments: false
  }, (collection) => {
    const relativePath = `${filename}.${collection.format}`;
    const mutationInfo = {
      includeCollection: true,
      includeTemplate: !!collection.templates
    };
    return /* @__PURE__ */ React.createElement(GetDocument, {
      cms,
      collectionName: collection.name,
      relativePath
    }, (document) => /* @__PURE__ */ React.createElement(RenderForm, {
      cms,
      document,
      filename,
      relativePath,
      collection,
      mutationInfo
    }));
  }));
};
const RenderForm = ({
  cms,
  document,
  filename,
  relativePath,
  collection,
  mutationInfo
}) => {
  var _a, _b;
  const [formIsPristine, setFormIsPristine] = useState(true);
  const schema = cms.api.tina.schema;
  const schemaCollection = schema.getCollection(collection.name);
  const template = schema.getTemplateForData({
    collection: schemaCollection,
    data: document._values
  });
  const formInfo = resolveForm({
    collection: schemaCollection,
    basename: schemaCollection.name,
    schema,
    template
  });
  const form = useMemo(() => {
    return new Form({
      id: "update-form",
      label: "form",
      fields: formInfo.fields,
      initialValues: document._values,
      onSubmit: async (values) => {
        try {
          await updateDocument(cms, relativePath, collection, mutationInfo, values);
          cms.alerts.success("Document updated!");
        } catch (error) {
          console.error(error);
          throw new Error(`[${error.name}] UpdateDocument failed: ${error.message}`);
        }
      }
    });
  }, [cms, document, relativePath, collection, mutationInfo]);
  const navBreakpoint = 1e3;
  const windowWidth = useWindowWidth();
  const renderNavToggle = windowWidth < navBreakpoint + 1;
  const headerPadding = renderNavToggle ? "px-20" : "px-6";
  return /* @__PURE__ */ React.createElement(PageWrapper, null, /* @__PURE__ */ React.createElement(React.Fragment, null, ((_b = (_a = cms == null ? void 0 : cms.api) == null ? void 0 : _a.tina) == null ? void 0 : _b.isLocalMode) ? /* @__PURE__ */ React.createElement(LocalWarning, null) : /* @__PURE__ */ React.createElement(BillingWarning, null), /* @__PURE__ */ React.createElement("div", {
    className: `py-4 border-b border-gray-200 bg-white ${headerPadding}`
  }, /* @__PURE__ */ React.createElement("div", {
    className: "max-w-form mx-auto"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "mb-2"
  }, /* @__PURE__ */ React.createElement("span", {
    className: "block text-sm leading-tight uppercase text-gray-400 mb-1"
  }, /* @__PURE__ */ React.createElement(Link, {
    to: `/collections/${collection.name}`,
    className: "inline-block text-current hover:text-blue-400 focus:underline focus:outline-none focus:text-blue-400 font-medium transition-colors duration-150 ease-out"
  }, collection.label ? collection.label : collection.name), /* @__PURE__ */ React.createElement(HiChevronRight, {
    className: "inline-block -mt-0.5 opacity-50"
  })), /* @__PURE__ */ React.createElement("span", {
    className: "text-xl text-gray-700 font-medium leading-tight"
  }, "Edit ", `${filename}.${collection.format}`)), /* @__PURE__ */ React.createElement(FormStatus, {
    pristine: formIsPristine
  }))), /* @__PURE__ */ React.createElement(FormBuilder, {
    form,
    onPristineChange: setFormIsPristine
  })));
};
const ScreenPage = () => {
  const { screenName } = useParams();
  const navBreakpoint = 1e3;
  const windowWidth = useWindowWidth();
  const renderNavToggle = windowWidth < navBreakpoint + 1;
  return /* @__PURE__ */ React.createElement(GetCMS, null, (cms) => {
    var _a, _b;
    const screens = cms.plugins.getType("screen").all();
    const selectedScreen = screens.find(({ name }) => slugify(name) === screenName);
    return /* @__PURE__ */ React.createElement("div", {
      className: "relative w-full h-full flex flex-col items-stretch justify-between"
    }, ((_b = (_a = cms == null ? void 0 : cms.api) == null ? void 0 : _a.tina) == null ? void 0 : _b.isLocalMode) ? /* @__PURE__ */ React.createElement(LocalWarning, null) : /* @__PURE__ */ React.createElement(BillingWarning, null), renderNavToggle && /* @__PURE__ */ React.createElement("div", {
      className: `py-5 border-b border-gray-200 bg-white pl-18`
    }, selectedScreen.name), /* @__PURE__ */ React.createElement("div", {
      className: "flex-1 overflow-y-auto relative flex flex-col items-stretch justify-between"
    }, /* @__PURE__ */ React.createElement(selectedScreen.Component, {
      close: () => {
      }
    })));
  });
};
const Redirect = () => {
  React.useEffect(() => {
    if (window) {
      window.location.assign("/");
    }
  }, []);
  return null;
};
const MaybeRedirectToPreview = ({
  redirect,
  children
}) => {
  const navigate = useNavigate();
  React.useEffect(() => {
    if (redirect) {
      navigate("/~");
    }
  }, [redirect]);
  return children;
};
const SetPreviewFlag = ({
  preview,
  cms
}) => {
  React.useEffect(() => {
    if (preview) {
      cms.flags.set("tina-iframe", true);
    }
  }, [preview]);
  return null;
};
const PreviewInner = ({ preview, config }) => {
  const params = useParams();
  const navigate = useNavigate();
  const [url, setURL] = React.useState(`/${params["*"]}`);
  const [reportedURL, setReportedURL] = useState(null);
  const ref = React.useRef(null);
  const paramURL = `/${params["*"]}`;
  React.useEffect(() => {
    if (reportedURL !== paramURL && paramURL) {
      setURL(paramURL);
    }
  }, [paramURL]);
  React.useEffect(() => {
    if ((reportedURL !== url || reportedURL !== paramURL) && reportedURL) {
      navigate(`/~${reportedURL}`);
    }
  }, [reportedURL]);
  React.useEffect(() => {
    setInterval(() => {
      var _a;
      if (ref.current) {
        const url2 = new URL(((_a = ref.current.contentWindow) == null ? void 0 : _a.location.href) || "");
        if (url2.origin === "null") {
          return;
        }
        const href = url2.href.replace(url2.origin, "");
        setReportedURL(href);
      }
    }, 100);
  }, [ref.current]);
  const Preview = preview;
  return /* @__PURE__ */ React.createElement(Preview, {
    url,
    iframeRef: ref,
    ...config
  });
};
const TinaAdmin = ({
  preview,
  config
}) => {
  const isSSR2 = typeof window === "undefined";
  const { edit } = useEditState();
  if (isSSR2) {
    return null;
  }
  if (!edit) {
    return /* @__PURE__ */ React.createElement(Layout, null, /* @__PURE__ */ React.createElement(LoginPage, null));
  }
  return /* @__PURE__ */ React.createElement(GetCMS, null, (cms) => {
    const isTinaAdminEnabled = cms.flags.get("tina-admin") === false ? false : true;
    if (isTinaAdminEnabled) {
      return /* @__PURE__ */ React.createElement(HashRouter, null, /* @__PURE__ */ React.createElement(SetPreviewFlag, {
        preview,
        cms
      }), /* @__PURE__ */ React.createElement(Routes, null, preview && /* @__PURE__ */ React.createElement(Route, {
        path: "/~/*",
        element: /* @__PURE__ */ React.createElement(PreviewInner, {
          config,
          preview
        })
      }), /* @__PURE__ */ React.createElement(Route, {
        path: "collections/:collectionName/new",
        element: /* @__PURE__ */ React.createElement(DefaultWrapper, {
          cms
        }, /* @__PURE__ */ React.createElement(CollectionCreatePage, null))
      }), /* @__PURE__ */ React.createElement(Route, {
        path: "collections/:collectionName/:templateName/new",
        element: /* @__PURE__ */ React.createElement(DefaultWrapper, {
          cms
        }, /* @__PURE__ */ React.createElement(CollectionCreatePage, null))
      }), /* @__PURE__ */ React.createElement(Route, {
        path: "collections/:collectionName/*",
        element: /* @__PURE__ */ React.createElement(DefaultWrapper, {
          cms
        }, /* @__PURE__ */ React.createElement(CollectionUpdatePage, null))
      }), /* @__PURE__ */ React.createElement(Route, {
        path: "collections/:collectionName",
        element: /* @__PURE__ */ React.createElement(DefaultWrapper, {
          cms
        }, /* @__PURE__ */ React.createElement(CollectionListPage, null))
      }), /* @__PURE__ */ React.createElement(Route, {
        path: "screens/:screenName",
        element: /* @__PURE__ */ React.createElement(DefaultWrapper, {
          cms
        }, /* @__PURE__ */ React.createElement(ScreenPage, null))
      }), /* @__PURE__ */ React.createElement(Route, {
        path: "logout",
        element: /* @__PURE__ */ React.createElement(DefaultWrapper, {
          cms
        }, /* @__PURE__ */ React.createElement(LogoutRedirect, null))
      }), /* @__PURE__ */ React.createElement(Route, {
        path: "/",
        element: /* @__PURE__ */ React.createElement(MaybeRedirectToPreview, {
          redirect: !!preview
        }, /* @__PURE__ */ React.createElement(DefaultWrapper, {
          cms
        }, /* @__PURE__ */ React.createElement(DashboardPage, null)))
      })));
    } else {
      return /* @__PURE__ */ React.createElement(Layout, null, /* @__PURE__ */ React.createElement(HashRouter, null, /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(Route, {
        path: "logout",
        element: /* @__PURE__ */ React.createElement(LogoutPage, null)
      }), /* @__PURE__ */ React.createElement(Route, {
        path: "/",
        element: /* @__PURE__ */ React.createElement(Redirect, null)
      }))));
    }
  });
};
const DefaultWrapper = ({
  cms,
  children
}) => {
  return /* @__PURE__ */ React.createElement(Layout, null, /* @__PURE__ */ React.createElement("div", {
    className: "flex items-stretch h-screen overflow-hidden"
  }, /* @__PURE__ */ React.createElement(Sidebar, {
    cms
  }), /* @__PURE__ */ React.createElement("div", {
    className: "flex-1 relative"
  }, children)));
};
class RouteMappingPlugin {
  constructor(mapper) {
    this.__type = "tina-admin";
    this.name = "route-mapping";
    this.mapper = mapper;
  }
}
const defineSchema = (config) => {
  validateSchema({ schema: config });
  return config;
};
const defineLegacyConfig = (config) => {
  validateSchema({ schema: config.schema });
  return config;
};
const defineStaticConfig = (config) => {
  if (!config.schema) {
    throw new Error("Static config must have a schema");
  }
  validateSchema({ schema: config.schema });
  return config;
};
const defineConfig = defineStaticConfig;
export { AuthWallInner, Client, DEFAULT_LOCAL_TINA_GQL_SERVER_URL, LocalClient, RouteMappingPlugin, TinaAdmin, TinaAdminApi, TinaCMSProvider2, TinaCloudAuthWall, TinaCloudProvider, TinaDataProvider, assertShape, createClient, TinaCMSProvider2 as default, defineConfig, defineLegacyConfig, defineSchema, defineStaticConfig, getStaticPropsForTina, gql, safeAssertShape, staticRequest, useDocumentCreatorPlugin, useGraphqlForms, useTinaAuthRedirect };
