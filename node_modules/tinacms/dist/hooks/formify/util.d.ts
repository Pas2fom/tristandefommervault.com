/**

*/
import { Form, Field, TinaCMS } from '@tinacms/toolkit';
import type { DocumentBlueprint, FieldBlueprint, FormifiedDocumentNode, OnChangeEvent, FormNode, State, ChangeSet, BlueprintPath } from './types';
import { formifyCallback, onSubmitArgs } from '../use-graphql-forms';
interface RecursiveFormifiedDocumentNode<T extends object> extends Array<RecursiveFormifiedDocumentNode<T> | T> {
}
/**
 * Gets the value from an object for a given blueprint for _all_ possible values.
 * eg. If the blueprint is `getCollection.documents.edges.[].node` and the value is:
 * ```
 * {
 *   getCollection: {
 *      documents: {
 *        edges: [{
 *          node: valueA
 *        },
 *        {
 *          node: valueB
 *        }]
 *      }
 *   }
 * }
 * ```
 * The response would be an array containing `valueA` and `valueB`
 *
 */
export declare const getValueForBlueprint: <T extends object>(state: object, path: string) => T | RecursiveFormifiedDocumentNode<T>;
/**
 * Returns the name of the field. In the example query, `title` and `t` would both be blueprint fields
 *
 * ```graphql
 * {
 *   getPostDocument(relativePath: $relativePath) {
 *     data {
 *       title,
 *       t: title # here `t` is an alias for title
 *     }
 *   }
 * }
 * ```
 */
export declare const getFieldNameOrAlias: (fieldBlueprint: FieldBlueprint) => string;
export declare const buildForm: (doc: FormifiedDocumentNode, cms: TinaCMS, formify: formifyCallback, showInSidebar?: boolean, onSubmit?: (args: onSubmitArgs) => void) => Form;
export declare const formNodeId: (formNode: FormNode) => string;
export declare const formNodePath: (formNode: FormNode) => string;
export declare const formNodeNotIn: (formNode: FormNode, formNodes: FormNode[]) => boolean;
export declare const sequential: <A, B>(items: A[], callback: (args: A, idx: number) => Promise<B>) => Promise<B[]>;
export declare const getFormNodesForField: (fieldBlueprint: FieldBlueprint, formNode: FormNode, event: OnChangeEvent, state: State) => {
    pathToChange: string;
    formNodes: FormNode[];
    eventLocation: any[];
    existing: any;
};
export declare const getBlueprintAliasPath: (blueprint: DocumentBlueprint) => string;
export declare const getFieldAliasForBlueprint: (path: BlueprintPath[]) => string;
/**
 *
 * Determines the appropriate fields which should recieve an update from a form change
 *
 * In cases where there's polymorphic blocks, it's possible that an update would affect
 * multiple locations that it shouldn't.
 *
 * An OnChange event name can look like: `blocks.2.title`, but if there are 2 block elements
 * with a field of the same name, an event name it wouldn't be enough information for us.
 *
 * To get around this, the event sends the current `typename` along with it, and we use that
 * to determine where in our blueprint the value should be updated.
 *
 */
export declare const getBlueprintFieldsForEvent: (blueprint: DocumentBlueprint, event: OnChangeEvent) => FieldBlueprint[];
export declare const filterFieldBlueprintsByParentTypename: (fbp: FieldBlueprint, typename: any) => boolean;
/**
 *
 * Returns the human-readable path to a blueprint or blueprint field.
 * Optionally, appends a disambiguator to the string where necessary.
 *
 * eg. if a blocks field is polymporphic, specifying `true` for the disambiguator
 *
 * ```
 * getPageDocument.data.blocks[].PageBlocksCta.title
 * ```
 */
export declare const getBlueprintNamePath: (blueprint: Pick<DocumentBlueprint, 'path'>, disambiguator?: boolean) => string;
export declare const stripIndices: (string: any) => any[];
export declare const replaceRealNum: (string: any) => any;
export declare const getMatchName: ({ field, prefix, blueprint }: {
    field: any;
    prefix: any;
    blueprint: any;
}) => {
    matchName: string;
    fieldName: any;
};
export declare const getFormNodesFromEvent: (state: State, event: OnChangeEvent) => FormNode[];
export declare const printState: (state: State) => string;
export declare const printEvent: (event: OnChangeEvent) => {
    type: "forms:fields:onChange" | "forms:reset";
    value: unknown;
    previousValue: unknown;
    mutationType: import("./types").ChangeMutation | import("./types").ReferenceChangeMutation | import("./types").InsertMutation | import("./types").MoveMutation | import("./types").RemoveMutation | import("./types").ResetMutation | import("./types").GlobalMutation;
    formId: string;
    field: {
        data: {
            tinaField: {
                name: string;
                type: "string" | "object" | "reference";
                list?: boolean;
                parentTypename: string;
            };
        };
        name: string;
    };
};
export declare const getFormNodeBlueprint: (formNode: FormNode, state: State) => DocumentBlueprint;
export declare const getMoveMapping: (existing: any, from: any, to: any) => {
    [key: number]: number;
};
export declare const matchLocation: (eventLocation: number[], formNode: FormNode) => boolean;
export declare const bumpLocation: (location: number[]) => number[];
export declare const maybeLowerLocation: (location: number[], at: number) => number[];
export declare const matchesAt: (location: number[], at: number) => boolean;
export declare const swapLocation: (location: number[], mapping: {
    [key: number]: number;
}) => number[];
/**
 *
 * Gets the sub-fields for an object field, if it's a polymorphic
 * object then we also need to get the __typename, though
 * we should probably supply that regardless. The current downside
 * of this is that it needs to come from the server because we
 * have no way of knowing what it would be from the client-side
 */
export declare const getSubFields: (changeSet: ChangeSet) => {
    fields: Field[];
    __typename: string;
};
export {};
